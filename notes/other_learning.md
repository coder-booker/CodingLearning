# Other learning

### regex
- 复健练习
    - /(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/ 这是用来匹配和划分协议、域名、端口、子路径的正则

- Summarized rules: 
- 重要概念
    - 从左到右匹配
    - 不在字符类里的东西都是整个字段匹配，但要酌情转义。在字符类里的东西除了规则就一定是逐个逐个匹配，甚至不用转义
    - `+`和`*`都是贪婪的，会尽可能匹配多的内容再返回
        - 可以在后面加一个`?`来一匹配到符合规则的第一个最小子串就立刻返回
        - e.g.`<h1>RUNOOB-菜鸟教程</h1>`，`/<.*>/` 会匹配到整段，`/<.*?>/`则会匹配到第一个`<h1>` 
    - 不在中括号内的`^`以及`$`仅用于匹配段落开头结尾及贴着的子串
        - 并不是任何正则表达式都要用^和$开头结尾，而是想要只匹配在段落开头或结尾的紧贴着的子串才写
        - 两个都写就是匹配一整句话
        - 而`\b`则用于仅匹配词开头或结尾的子串
    - 没匹配到的行为
        - 如果是`+`就不会返回任何东西，`*`或者`?`则有可能返回些什么
        - 留意，一般都是返回null，但捕获组如果用`*`或者?则会返回 *undefined*
- 正则库使用
    - `[str].match([regex])`
        - 返回一个*数组*，包含匹配结果和捕获组内容
        - 如果不做任何处理，默认匹配一个结果就立刻返回
        - 加了修饰符`g`就不会有捕获组内容
    - `[str].matchAll([regex])`
        - 全局匹配，这里的[regex] 必须包含修饰符`g`
        - 返回的是迭代器，迭代器迭代的是n个数组，数组里的元素是匹配到的内容和(如有)对应的捕获组内容
    - `[regex].exec([str])`
        - 用yield返回的`.match`，每次调用都会从上次匹配到的地方后返回一个数组，包含匹配结果和捕获组内容，且只匹配一次
        - 所以一般用while包exec来遍历
        - 有`g`才能如预期进行，无`g`就只会无限循环返回第一个匹配到的结果
    - `[regex].test([str])`
        - 只要匹配到一次就返回true
- 修饰符
    - 修饰符加在正则表达式最后，eg：`/.../x`x为修饰符
    - `g`：全局匹配
        - `.match()`+`g`全局匹配但默认忽略捕获组捕获的内容
        - `.matchAll()`+`g`则仍然保留捕获组缓冲内容
    - `i`：表示不区分大小写
    - `m`：多行匹配，也就是`^`和`$`不再只匹配字符串开头结尾，而是以换行符`\n`为分界线匹配
    - `s`：让`.`可以匹配换行符

- 字符匹配
    - `.`: 除换行符(\r, \n)外的任意一个字符。`a.c`就是匹配任意一个ac夹住单个字符的字段
    - 直接写就整段直接匹配
        - 注意中括号内的话就会视为独立字符而非一个词
    - 空格也会被识别，注意和`\s`不一样
    - 还有一些元字符啥的，比如\t, \f, \r, \n
    - 甚至还可以匹配八进制和十六进制的内容
- 字符类
    - `[]`: 用来匹配里面任意一个字符或者规则
        - 字符的话，大部分符号和字符直接写进去就行
            - `[abc_]`表示匹配a b c _其中一个字符
        - 规则
            - `[a-zA-Z0-9]`表示所有小写字母大写字母数字
        - 取反
            - 加个`^`取反，方括号内所有规则都会反，eg `[^a-z0-9]`表示所有非小写字母和非数字
- 预定义字符类
    - `\d`, `\D`：匹配数字([0-9])；匹配非数字([^0-9])
    - `\w`, `\W`：匹配任何字母数字下划线([a-zA-Z0-9_])；匹配任何非字母数字下划线([^a-zA-Z0-9_])
    - `\s`, `\S`：匹配任何空白字符，包括空格、制表符、换页符等；匹配任何非空白字符，包括空格、制表符、换页符等
- 边界匹配/定位符
    - `^`：不在方括号内时，表示开头
        - `^abc` 匹配以 "abc" 开头的字符串。
    - `$`：匹配字符串的结束。
        - `abc$` 匹配以 "abc" 结尾的字符串。
    - `\b`：匹配单词边界。
        - `\bword\b` 匹配完整的单词 "word"。
    - `\B`：匹配非单词边界。
        - `\Bword\B` 匹配 "password" 中的 "word"。
- 量词
    - `*`：匹配前面的字符零次或多次。
        - `a*` 匹配 "", "a", "aa" 等。
        - = `{0,}`
    - `+`：匹配前面的字符一次或多次。
        - `a+` 匹配 "a", "aa", "aaa" 等。
        - = `{1,}`
    - `?`：匹配前面的字符零次或一次。
        - `a?` 匹配 "", "a"。
        - = `{0,1}`
    - `{n}`：匹配前面的字符恰好 n 次。
        - `a{3}` 匹配 "aaa"。
    - `{n,}`：匹配前面的字符至少 n 次。
        - `a{2,}` 匹配 "aa", "aaa", "aaaa" 等。
    - `{n,m}`：匹配前面的字符至少 n 次，至多 m 次。
        - `a{2,4}` 匹配 "aa", "aaa", "aaaa"。
- 分组和捕获
    - `(...)`：将表达式括起来，形成一个分组，并捕获匹配的内容。
        - `(abc)` 匹配 "abc"。
        - 注意捕获组会把其内规则捕获到的那段字符缓冲和返回出来
            - e.g. `/([a-z])([0-9]+)/`匹配`a123`会返回`[a123,a,123]`
            - e.g.2 `/([0-9]+)/`匹配`123`会返回`[123,123]`
        - `\...`：反向引用前面缓冲的内容，...是分组的编号。
            - `(\d)\1` 匹配两个相同的数字，如 "11", "22"。
            - 只能被捕获分组使用，也只会引用缓冲/捕获的内容，不会引用匹配到的内容
        - 贪婪的情况下，只会缓冲最后一个捕获到的值
    - 非捕获元
        - `(?:...)`：不捕获匹配的内容。
            - `(?:abc)` 匹配 "abc"但不捕获。
        - `...(?=...)`匹配括号内匹配到的内容前的匹配内容
        - `...(?!...)`匹配不是括号内匹配到的内容前的匹配内容
        - `(?<=...)...`匹配括号内匹配到的内容后的匹配内容
        - `(?<!...)...`匹配不是括号内匹配到的内容后的匹配内容
- 选择和分支
    - `|`：表示选择或分支，匹配 | 两边的任意一个表达式。
        - `a|b` 匹配 "a" 或 "b"。
- 转义字符
    - `\`：用于转义特殊字符，使其作为普通字符匹配。
        - \. 匹配 "."，\* 匹配 "*"。
- 正则优化
    - 非贪婪匹配、避免嵌套


### .env
- 标示着环境变量
    - eg `AUTH_SECRET = sfcascasfc`
- 需要读取时声明类型，不然一般都是字符串
- `.env.local`
    - 标识开发环境的环境变量
    - 和.env同时存在时，.env.local优先级更高（同样的键值对会被.env.local覆盖）

### windows
- 软链接
    - 管理员运行cmd
    - `mklink [目标链接] [源链接]`
    - `/d` flag来链接文件夹
    - 目标链接不可先前就存在（可能有对应exist_ok的flag，但目前没必要学）

### 术语
- slug
    - 用于url其中一部分的字符串
- enumerate和traverse
    - 都是列举所有内容的用词，但前者只列举，后者可能还会做点操作


### 路径
- `/**`表示任意层级的任意子路径，eg `/a`, `/a/b`, `/a/b/c`都会被匹配到
- `/*`表示该路径下的任意一层子路径，e.g.`/a`, `/b`, `/c`
- `/**/*`则可以匹配任意路径

### 系统位数
- amd/amd64
    - x86架构的32/64位CPU
    - 主流电脑和服务器用的
- arm/arm64
    - arm架构的32/64位CPU
    - 一般是手机平板苹果用的