

# regex
- 复健练习
    - /(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/ 这是用来匹配和划分协议、域名、端口、子路径的正则

- Summarized rules: 
- 重要概念
    - 从左到右匹配。
    - 不在字符类里的东西都是整个字段匹配，但要酌情转义。在字符类里的东西除了规则就一定是逐个逐个匹配，甚至不用转义
    - `+`和`*`都是贪婪的，会尽可能匹配多的内容再返回
        - 可以在后面加一个`?`来一匹配到符合规则的第一个最小子串就立刻返回
        - e.g.`<h1>RUNOOB-菜鸟教程</h1>`，`/<.*>/` 会匹配到整段，`/<.*?>/`则会匹配到第一个`<h1>` 
    - 不在中括号内的`^`以及`$`仅用于匹配段落开头结尾及贴着的子串
        - 并不是任何正则表达式都要用^和$开头结尾，而是想要只匹配在段落开头或结尾的紧贴着的子串才写
        - 两个都写就是匹配一整句话
        - 而`\b`则用于仅匹配词开头或结尾的子串
    - 没匹配到的行为
        - 如果是`+`就不会返回任何东西，`*`或者`?`则有可能返回些什么，比如`"abc efg".match(/\w*/)`就会因为abc匹配完之后继续向右，空格无法匹配会返回""之类的东西，最后结果就是`['abc', '', efg]`
        - 留意，一般都是返回null，但捕获组如果用`*`或者`?`则会返回 *undefined*
- 正则库使用
    - `[str].match([regex])`
        - 返回一个*数组*，包含匹配结果和捕获组内容
        - 如果不做任何处理，默认匹配一个结果就立刻返回
        - 加了修饰符`g`就不会有捕获组内容
        - 注意对于`+*`这一类符号，因为这符号本身就会全部匹配一遍，行为可能会和matchAll相似（比如匹配到了一个之后还会接着找有没有），不要搞混了
    - `[str].matchAll([regex])`
        - 全局匹配，这里的[regex] 必须包含修饰符`g`
        - 返回的是迭代器，迭代器迭代的是n个数组，数组里的元素是匹配到的内容和(如有)对应的捕获组内容
    - `[regex].exec([str])`
        - 用yield返回的`.match`，每次调用都会从上次匹配到的地方后返回一个数组，包含匹配结果和捕获组内容，且只匹配一次
        - 所以一般用while包exec来遍历
        - 有`g`才能如预期进行，无`g`就只会无限循环返回第一个匹配到的结果
    - `[regex].test([str])`
        - 只要匹配到一次就返回true
- 修饰符
    - 修饰符加在正则表达式最后，eg：`/.../x`x为修饰符
    - `g`：全局匹配
        - `.match()`+`g`全局匹配但默认忽略捕获组捕获的内容
        - `.matchAll()`+`g`则仍然保留捕获组缓冲内容
    - `i`：表示不区分大小写
    - `m`：多行匹配，也就是`^`和`$`不再只匹配字符串开头结尾，而是以换行符`\n`为分界线匹配
    - `s`：让`.`可以匹配换行符

- 字符匹配
    - `.`: 除换行符(\r, \n)外的任意一个字符。`a.c`就是匹配任意一个ac夹住单个字符的字段
    - 直接写就整段直接匹配
        - 注意中括号内的话就会视为独立字符而非一个词
    - 空格也会被识别，注意和`\s`不一样
    - 还有一些元字符啥的，比如\t, \f, \r, \n
    - 甚至还可以匹配八进制和十六进制的内容
- 字符类
    - `[]`: 用来匹配里面任意一个字符或者规则
        - 字符的话，大部分符号和字符直接写进去就行
            - `[abc_]`表示匹配a b c _其中一个字符
        - 规则
            - `[a-zA-Z0-9]`表示所有小写字母大写字母数字
        - 取反
            - 加个`^`取反，方括号内所有规则都会反，eg `[^a-z0-9]`表示所有非小写字母和非数字
- 预定义字符类
    - `\d`, `\D`：匹配数字([0-9])；匹配非数字([^0-9])
    - `\w`, `\W`：匹配任何字母数字下划线([a-zA-Z0-9_])；匹配任何非字母数字下划线([^a-zA-Z0-9_])
    - `\s`, `\S`：匹配任何空白字符，包括空格、制表符、换页符等；匹配任何非空白字符，包括空格、制表符、换页符等
- 边界匹配/定位符
    - `^`：不在方括号内时，表示开头
        - `^abc` 匹配以 "abc" 开头的字符串。
    - `$`：匹配字符串的结束。
        - `abc$` 匹配以 "abc" 结尾的字符串。
    - `\b`：匹配单词边界。
        - `\bword\b` 匹配完整的单词 "word"。
    - `\B`：匹配非单词边界。
        - `\Bword\B` 匹配 "password" 中的 "word"。
- 量词
    - `*`：匹配前面的字符零次或多次。
        - `a*` 匹配 "", "a", "aa" 等。
        - = `{0,}`
    - `+`：匹配前面的字符一次或多次。
        - `a+` 匹配 "a", "aa", "aaa" 等。
        - = `{1,}`
    - `?`：匹配前面的字符零次或一次。
        - `a?` 匹配 "", "a"。
        - = `{0,1}`
    - `{n}`：匹配前面的字符恰好 n 次。
        - `a{3}` 匹配 "aaa"。
    - `{n,}`：匹配前面的字符至少 n 次。
        - `a{2,}` 匹配 "aa", "aaa", "aaaa" 等。
    - `{n,m}`：匹配前面的字符至少 n 次，至多 m 次。
        - `a{2,4}` 匹配 "aa", "aaa", "aaaa"。
- 分组和捕获
    - `(...)`：将表达式括起来，形成一个分组，并捕获匹配的内容。
        - `(abc)` 匹配 "abc"。
        - 注意捕获组会把其内规则捕获到的那段字符缓冲和返回出来
            - e.g. `/([a-z])([0-9]+)/`匹配`a123`会返回`[a123,a,123]`
            - e.g.2 `/([0-9]+)/`匹配`123`会返回`[123,123]`
        - `\...`：反向引用前面缓冲的内容，...是分组的编号。
            - `(\d)\1` 匹配两个相同的数字，如 "11", "22"。
            - 只能被捕获分组使用，也只会引用缓冲/捕获的内容，不会引用匹配到的内容
        - 贪婪的情况下，只会缓冲最后一个捕获到的值
    - 非捕获元
        - `(?:...)`：不捕获匹配的内容。
            - `(?:abc)` 匹配 "abc"但不捕获。
        - `...(?=...)`匹配括号内匹配到的内容前的匹配内容
        - `...(?!...)`匹配不是括号内匹配到的内容前的匹配内容
            - 这个用的好的话可以用来进行 `!=` 判断
        - `(?<=...)...`匹配括号内匹配到的内容后的匹配内容
        - `(?<!...)...`匹配不是括号内匹配到的内容后的匹配内容
- 选择和分支
    - `|`：表示选择或分支，匹配 | 两边的任意一个表达式。
        - `a|b` 匹配 "a" 或 "b"。
- 转义字符
    - `\`：用于转义特殊字符，使其作为普通字符匹配。
        - \. 匹配 "."，\* 匹配 "*"。
- 正则优化
    - 非贪婪匹配、避免嵌套
# ASCII
- 0-31：    奇奇怪怪的东西
- 32-47：   部分符号
- 48-57：   数字0-9
- 58-64：   部分符号
- 65-90：   大写字母
- 91-96：   部分符号
- 97-122：  小写字母
- 123-126： 部分符号
- 127：     DEL

# 哈希
- consistent hashing 一致性哈希
    - 哈希环：将哈希空间视为一个环（0到2^32-1），数据和节点都通过哈希函数映射到环上的某个位置。
    - 数据分配：数据存储在顺时针方向最近的节点上。
    - 动态扩展与收缩：添加或删除节点时，只需重新分配少量数据，而不是全部。

# 规范化版本管理
- SemVer
    - 版本号的管理
    - MAJOR.MINOR.PATCH[-PRERELEASE]
    - 包括
        - MAJOR 主版本号：必须（MUST）在有任何不兼容的修改被加入公共 API 时递增。其中可以（MAY）包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须（MUST）归零。
        - MINOR 次版本号：必须（MUST）在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也必须（MUST）递增。也可以（MAY）在内部程序有大量新功能或改进被加入时递增，其中可以（MAY）包括修订级别的改变。每当次版本号递增时，修订号必须（MUST）归零。
        - PATCH 修订号：必须（MUST）在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。
        - PRERELEASE 先行版本号可以（MAY）：被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。数字型的标识符禁止（MUST NOT）在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。
- Conventional Commit
    - 基础范式：
        ```
        <type>[optional scope]: <description>

        [optional body]

        [optional footer(s)]
        ```
    - type
        - fix: 类型 为 fix 的提交表示在代码库中修复了一个 bug（这和语义化版本中的 PATCH 相对应）。
        - feat: 类型 为 feat 的提交表示在代码库中新增了一个功能（这和语义化版本中的 MINOR 相对应）。
        - build: 用于修改项目构建系统，例如修改依赖库、外部接口或者升级 Node 版本等；
        - chore: 用于对非业务性代码进行修改，例如修改构建流程或者工具配置等；
        - ci: 用于修改持续集成流程，例如修改 Travis、Jenkins 等工作流配置；
        - docs: 用于修改文档，例如修改 README 文件、API 文档等；
        - style: 用于修改代码的样式，例如调整缩进、空格、空行等；
        - refactor: 用于重构代码，例如修改代码结构、变量名、函数名等但不修改功能逻辑；
        - perf: 用于优化性能，例如提升代码的性能、减少内存占用等；
        - test: 用于修改测试用例，例如添加、删除、修改代码的测试用例等。
        - 其他：type后加`!`是BREAK CHANGE的语法糖
    - optional scope
        - 这个比较随机，可行的例子有：(api)、(lang)之类的
    - description
        - 对此次commit的简易描述
    - optional body：
        - 详细描述。第一个段落前和每个段落间都要空一行（注意其实就是和上一句隔了两个换行符）
    - optional footer：
        - 如：
            - Reviewed-by: xxxx
            - Refs: #123（也可以是另一个commit的id）
            - BREAKING CHANGE：xxxxyyyy（破坏性 API 变更，也就是需要改 MAJOR 的commit）

# 奇怪的电脑知识
### .env
- 标示着环境变量
    - eg `AUTH_SECRET = sfcascasfc`
- 需要读取时声明类型，不然一般都是字符串
- `.env.local`
    - 标识开发环境的环境变量
    - 和.env同时存在时，.env.local优先级更高（同样的键值对会被.env.local覆盖）
### 术语
- slug：用于url其中一部分的字符串
- enumerate和traverse：都是列举所有内容的用词，但前者只列举，后者可能还会做点操作
### 路径格式
- `/**`表示任意层级的任意子路径，eg `/a`, `/a/b`, `/a/b/c`都会被匹配到
- `/*`表示该路径下的任意一层子路径，e.g.`/a`, `/b`, `/c`
- `/**/*`则可以匹配任意路径


# windows
### 有用的功能
- 软链接
    - 管理员运行cmd
    - `mklink [目标链接] [源链接]`
    - `/d` flag来链接文件夹
    - 目标链接不可先前就存在（可能有对应exist_ok的flag，但目前没必要学）
- 硬链接
    - 可以这么类比：软链接是弱引用，硬链接是强引用。所以软链接无法阻止源文件被删除，而硬链接在源文件被删除之后会使最终的内存仍然被保，直到所有硬链接都被删除。
- 文件目录树
    - `tree`: 只显示directory
        - `/F`: 显示文件
### 系统位数
- amd/amd64
    - x86架构的32/64位CPU
    - 主流电脑和服务器用的
- arm/arm64
    - arm架构的32/64位CPU
    - 一般是手机平板苹果用的



# VSCode
### 快捷键
- 终端: Ctrl + `
- setting搜索: Ctrl + Shift + p
- 游标整词移动：Ctrl + 方向
- 手动触发code hint: Alt + s (我自己绑定的，原本是 Ctrl + Space)
- 任何父级(或者自动选中的)括号快捷删除(包括左右): Ctrl + Alt + Backspace
- 快捷选中所有相同内容：Ctrl + Shift + L
- 快捷选中上下行相同位置的内容：Ctrl + Shift + Alt + 上下
- 全局搜索文件：Ctrl + T
- 关闭所有标签页：Ctrl + K + W
- 创建文件：Ctrl + Shift + Alt + F
- 创建文件夹: Ctrl + Shift + Alt + D
- 切换到文件视窗：Ctrl + 0
### 拓展
- snippet creator
- vscode pet
- toggle quotes
    - shortcut: Ctrl + '
- console ninja
    - js/ts fast console.log when server launched
- 内置的snippet
    - ToolBar -> File -> Preference -> Configure Snippets
    - settings.json:  
        ```
        "[<filename>]":  {
            "editor.quickSuggestions": true
        }
        ```

