### How to solve customers complaint
- Stay Calm and Empathetic
    - 说明一些聆听技巧、阅读技巧之类的
- Identify the Root Cause: 
    - Highlight your problem-solving skills by ***discussing how you investigate the underlying issue.*** 
    - Mention specific techniques like asking ***clarifying questions or reviewing relevant data*** to pinpoint the problem.
    - try to describe the problem in a specific and ***structured*** way
- Offer Solutions: 
    - Describe how you ***present options*** to the customer and ***involve them in the decision-making process*** to ensure their satisfaction.
    - 必要时可以提供***补偿***或者临时方案
- Follow Up: 
    - Emphasize the importance of follow-through. Explain ***how you check back with the customer*** after resolving their complaint to ensure the solution was effective and to reinforce their trust in your service.
- Learn and Improve: 
    - Illustrate your commitment to continuous improvement by discussing ***how you analyze complaints to identify patterns and implement changes.*** Mention how you use feedback to enhance your approach and prevent future issues

### How to Trouble-shooting
- There are common steps: 
    1. identify the situation/context
    2. identify the problem
    3. brainstorm some solutions
    4. evaluate them and pick the best one
    5. implement
    6. evaluate the result

### career goal
- be specific. 
- eg: 
    - 我的短期目標是為一家***前景看好、能提供訓練課程和升遷機會***的公司工作。
    - 我的長期目標是在***加強解決問題的能力和人際技巧***的同時，***累積其他行銷相關經驗***。

### 你想通过这份工作得到什么？
- 和短期目标有点像，但需要和该工作更相关的回答

### What do you know about us
- 了解公司背景、行业背景、工作要求，以及这三者如何互相影响
- 还可以带上“因为我想追求xxx的目标和贵公司重合”

### Do you any questions?
- 重点。通过详细询问工作待遇和工作内容可以判断这家公司是否有雷。
- 工作待遇：
    - 实际薪资（排除五险一金/强积金），何时发放
    - 双休，工作时间
    - 加班补贴
- 工作内容：
    - 有无培训，有无人带
    - 内部架构，直属部门，具体工作内容（日常、项目工作等）
    - 直属领导






# Linkedin
### Profile
- headline【done】

- banner【done】

- pronounciation【done】

- About【done】
    - 一些准则
        - 可以讲下故事
        - 不要用奇怪的术语
        - 头三行算是重点，决定别人想不想继续看下去
    - 思考
        - 我真正想要的是什么？追求任何形式的欢愉，在一切之中找乐子。
            - 为此我可以提及：我愿意尝试新的东西和挑战，只是为了在其中找到乐趣
            - 这个也可以和我说“正在gap year寻求新的机会”这一目标相似，可以通过“新”这个元素融合
            - 例子就说：我在做parttime工作，领域是我毫无经验的语言学
            - 然后再说我接受任何形式的新挑战，并尝试结合我的专业只是来解决问题
        - 打游戏？爱好真的应该写进去吗？
        - 但谨记，我是为了找工作和connection。
    - 一些已经有的思路
        - 我觉得还是必须声明我在寻求更进一步的新发展，并且甚至为此申请了gap year
        - 然后提及我gladly喜欢尝试新的东西和挑战，只是为了在其中找到乐趣
            - 这个也可以和我说“正在gap year寻求新的机会”这一目标相似，可以通过“新”这个元素融合
            - 例子就说：我在做parttime工作，领域是我毫无经验的语言学
            - 然后再说我接受任何形式的新挑战，并尝试结合我的专业只是来解决问题
    - 最终script
    ```
    我一直以来都在尝试通过学习技术来得到成功，但随着时间的发展，我发现想要成为一名好的程序员，就必须不止步于程序员。为了探索和实现这个目标，我从我的大学中申请了一年的gap year，并在积极地寻找新的挑战，或者说机会。

    我曾认为代码这个工具能够解决任何问题，并一门心思深入其中。我曾与团队合作为初创公司构建网站，也于中国银行这类巨型企业做过实习。但我逐渐发现代码的局限性：电脑之外的世界太过复杂，哪怕最先进的AI也不是全知全能，总有些问题是我身为单纯的程序员无法解决的。于是我开始放眼更广泛的机会。在gap year中，我正在为大学兼职开发和维护一个语言学结合AI分析的聊天机器人平台。我从未接触过语言学，所幸我一直乐于学习新的事物--你总能在挑战中找到不为人知的乐趣。目前这个平台已经上线数月，供教师作教学用途，而我也学习到面对新挑战的乐趣，让我的gap year有了些许价值。
    
    我仍然热爱科技，但我会更加积极地向全新的领域开拓，并将我的技术发挥在更多方面上。在gap year中，我在积极地寻找长期的实习科技岗位，让我能通过更长地实习周期来学习更广泛的知识。如果你缺少一位愿意接受挑战的人，随时联系我

    I have always strived for success through learning technology, but over time, I realized that to become a great programmer, one must go beyond just coding. To explore and achieve this goal, I took a gap year from my university and am actively seeking new challenges and opportunities.

    I once believed that coding could solve any problem and dedicated myself to it. I have collaborated with teams to build websites for startups and interned at large corporations like the Bank of China. However, I gradually discovered the limitations of coding: the world outside computers is too complex, and even the most advanced AI is not omniscient. There are always problems that a mere programmer cannot solve. So, I began to look for broader opportunities.

    During my gap year, I have been part-time developing and maintaining a chatbot platform that combines linguistics with AI analysis for my university. Although I had no prior experience with linguistics, I have always enjoyed learning new things—you can always find hidden joys in challenges. This platform has been live for several months now, serving as a teaching tool for educators, and I have found value in my gap year through the joy of facing new challenges.

    I still have a passion for technology, but I am now more actively exploring new fields and applying my skills in various areas. During my gap year, I am actively seeking long-term tech internships that will allow me to learn a broader range of knowledge over an extended period. If you need someone who is willing to take on challenges, feel free to contact me.
    ```
    - 个人网站感觉也可以抽时间上一上

### connection
- 思路
    - 目的是有了connection之后，我可以得到更多职场知识，且对方更了解我一点了可以帮忙refer或者内推
    - 所有这个时候就有了两点需要注意：
        - 我想要知道什么职场知识？（这点需要因人而异，感觉就是直接搜索connection对象做过的工作、结合自己的情况问一下）（这点可以搜索一下“networking问啥问题比较好”）
        - connection对象是否合适？也就是我们要找谁做connection呢？
            - 1. 申请的公司的职员
            - 2. 和自己经历相似的人
            - 3. 只要是校友都可以connect一下
            - 4. 随机connect，比如曾经见过的人，讲师啥的。
        - 结论：refer可能没那么来得及，所以就以单纯的network和问职场经验为主吧
    - template
        - 
- target
- problem
    - career advice



# Interview prepare
### General/HR 面
- 个人经历
    - 自我介紹
        1. 基础资讯
        2. 硬技术
            - 技术栈：Reactjs、Nodejs、Nextjs
                - CorpusChat RAG、个人网页
        3. 软技能（在非大厂可以说）：
            - 实习/工作经历比较丰富
                - CorpusChat：完整产品开发经验，真实工作经历
                - 多段实习：大公司、小公司都去过
            <!-- - 在两地都生活过，更开阔的眼界能给我带来innovation -->
    - 期望薪资
    - 为什么投这个岗位？
        1. 个人发展：寻求前端的发展+喜好
            - 前端的开发
            - 转正机会、前沿的商业化工业化的技术
        2. 公司自己的优势
            - 字节跳动：始终创业 Always Day 1：展示了谦逊、上进心和初心
    - 拷打实习经历: 你从中学到了什么、实习中有什么困难之处
    - 报学校专业是怎么考虑的？
        - 本身比较擅长理科。大类收生、发现比较擅长和喜欢计算机
    - 缺点和优点？
        - 缺点：比较急
        - 优点：善于反思
    - 有没有哪段时间或者某件事情让你受挫/压力大/有挑战？
        - 朋友在大二就有不少offer
    - 你现在的技术薄弱点在哪里，怎么去突破？
        - 缺乏实操
    - 职业规划
        - 短期计划：大三找能够深入学习、有mentor的长期技术实习，学习成熟先进的技术，并寻求转正机会。
        - 长期计划：5年内深入了解毕业公司的技术架构和提升这一行业中的认知，成为业内的专业人士。
        - 更长期的计划：在我对业内的了解越来越多，自然就会慢慢显现出来
- 公司相关
    - 为什么选择这家公司
        - 科技公司，我一定能在其中学习到很多
        - 同时也能为有为行业贡献的机会
        - 平等和创新
    - 对之前几次面试的感受
    - 有没有了解过我们组的具体工作内容
    - 能为公司带来什么？
        - 学习能力比较强、自学经验比较多
    - 字节的工作压力比较大, 你认为能适应吗? 
    - 你期望的工作环境/公司是怎么样的
    - 你对下一份实习有什么期望
    - 什么情况下会考虑辞一份工作
    - 你能为公司带来什么
    - 你认为实习时可预见的困难
- other
    - 出来面试都了解过哪些企业？
    - 目前手上有 offer 吗？是否谈过薪资等？哪些因素决定你们选择这家公司?
        - 有，hk的企业。但这个机会我比较看重，且
    - 团队合作中遇到什么问题？
    - 对互联网加班有什么看法？
        - 无可厚非，且我之前也加班过，直接过夜了
    - 现在进度最快的公司是哪家？
        - HKSTP和字节
    - 反问
        - 培训
        - 内部架构、实际工作内容
        - 什么时候出结果
        - 薪资？
### 项目
- CorpusChat亮点：
    - 1. 真实项目，需要与客户沟通、设计整套软件流程。还涉及了一部分的UI设计
    - 2. 实现了一个很热门的概念：RAG，因此比较了解AI服务的一些前端要点，还给AI绑定了不少工具
    - 3. 全栈
    - 4. 云服务
- CorpusChat难点：
    - 使用了Azure的beta功能：AI 助理。实际开发中有很多不可控的因素，例如
        - 需要配合Azure云服务的数据结构，自己封装AI的输入与输出并与前端交互
            - 比如AI输出的内容是纯文字，我需要将其渲染为可读性更强的
        - beta功能有不完善的地方，源码有时会出现问题，需要在保证响应速度的同时妥善处理可能的错误信息
            - 比如AI assistant有时会输出到一半卡死报错，必须设置妥善前端逻辑来在流式输出时删除信息
        - 文档不清晰的地方常常需要阅读一部分源码
            - 比如后端需要
        - 客户要求有时候难以靠现有功能完成，只能自己解决
            - 这个比较后端，看看面试官想不想知道吧
- 你要知道你为什么用这个库和库的大致设计理念，甚至能够用js实现一个简易版本
- why Python but nodejs? 
    1. py开发效率高
    2. 客户要求
    3. Azure的openai assistant功能并没有nodejs的SDK
- technical difference btw python and nodejs
    - nodejs:
        - 基于事件驱动和非阻塞 I/O 模型，适合处理**I/O 密集型任务**（如文件操作、数据库查询）和**网络实时应用**（如 WebSocket、SSE）。
        - 单语言全栈开发，减少上下文切换
        - 生态系统统一且丰富（如 Express、NextJS 框架），工具链完整。
        - 社区活跃，更新频繁，支持现代开发实践。
        - 启动速度快，资源占用较少，适合微服务架构和 Serverless 场景。
        - **单线程模型**在处理 CPU 密集型任务（如复杂计算、图像处理）时性能较差。
            - 虽然可以通过 worker_threads 实现多线程，但复杂度较高。
    - python:
        - Python语法简洁，适合中小型项目或需要**快速迭代**的场景
        - 生态系统丰富
        - Python在算法实现和数据处理方面表现优异，如数据科学、机械学习等。
        - 更好的多线程和多进程支持，适合处理 CPU 密集型任务。
            - 但GIL（全局解释器锁）限制了多线程性能，需要asyio解决
        - Python是**解释型语言**，执行效率较低，不适合高并发或实时性要求高的场景。
            - 但可以通过多进程或异步编程（如 asyncio）优化。
        - Python 的异步性能和事件驱动机制不如 Node.js，不适合开发实时应用（如 WebSocket、SSE）。
前端：
- Redux
    - Context缺点
        - 大量switch来判断fetch操作
        - 性能问题：当 Context 的值发生变化时，所有消费该 Context 的组件都会重新渲染，即使它们只依赖 Context 的一部分数据。需要通过 useMemo 或 useCallback 优化性能。
        - 不适合复杂状态管理：缺乏 Redux 中的中间件、时间旅行调试等功能。且状态更新逻辑分散在各个组件中，难以集中管理。
        - 调试困难：没有 Redux DevTools 这样的强大调试工具。
    - Redux优点
        - 集中式状态管理：所有状态存储在单一的 Store 中，状态更新逻辑集中在 Reducer 中，加上状态分片，易于管理、追踪和测试。
        - 强大的中间件支持：支持中间件（如 redux-thunk、redux-saga），可以处理异步操作、日志记录等。
        - 时间旅行调试：通过 Redux DevTools，可以回溯和重放状态变化，方便调试。
        - 性能优化：通过 useSelector 选择性订阅状态，浅对比返回值，避免不必要的重新渲染。
    - 事实上react自己就有useReducer的钩子
        - 但很多东西都需要自己手动定义，例如action的type
        - redux还封装好了全局的state，而非仅当前组件内的state
    - Redux设计理念：
        - 统一状态管理
        - 把复杂的状态管理逻辑组合封装为一个个行为，提高可读性（也就是用文字的action来封装复杂的setState）
    - redux手动实现
        - listener队列：包含着所有订阅者的通知用回调函数（也就是selector）
        - subcribe函数：把订阅者的通知用回调函数传入listener队列。这个回调函数需要与组件声明周期挂钩，如useState的setter，useEffect的依赖数组值改变等等
        - reducer函数：传入action和state，并对action做出对应修改
        - dispatch函数：更改state，通知listener队列里对应的selector
        - useSelector钩子：封装subscribe和getState的钩子
            - 嵌套钩子原来也会重新渲染组件
        - getState函数：获得state
        - store：包含了state、reducer、listener的对应关系
        - 通过action的type和订阅时的type分片，只让指定的
    - 用action承载用以更改的数据，在reducer中把action里的数据更新到state中并通过selector广播
    - Slice：
        - name、initial state、reducers、extraReducers
        - name就是这个slice中所有同步action的type 前缀，后缀则是reducer的名字。
        - createSlice：reducer、action、action creator的语法糖
        - extraReducers：处理异步thunk的状态
            - 内置一些常用的一部状态，包括pending、fulfilled、rejected
    - Thunk：
        - 第一个参数是action type前缀。至于后缀则是thunk名
        - 第二个参数是一些给thunk用的redux API
            - 因为异步操作的复杂性，它的处理都是独立于其他同步reducer的，state也只能通过api获得。
        - 调用就是直接用thunk，但传入的参数会被传给第二个定义时的函数。
            - eg
                ```ts
                // incrementAsync(123)就是给amount传入123
                export const incrementAsync = createAsyncThunk(
                    'counter/incrementAsync',
                    async (amount, { dispatch, getState, rejectWithValue }) => {
                        // 模拟异步操作
                        await new Promise((resolve) => setTimeout(resolve, 1000));
                        dispatch(incrementByAmount(amount)); // 调用同步Action
                    }
                );
                ```
    - Store
        - 注册reducer、state、和他们的关系，让redux知道有哪些reducer和state被定义了，以及配置它们的对应关系，让reducer只会接到一小段配置给它的子state
        - store提供dispatch。每次dispatch都会遍历注册的reducer，让输入的action能找到其匹配的reducer
    - Selector
        - 使用useSelector从store中提取状态（如count和status）。
        - 得配合定义好的selector才能暴露给组件使用
            - eg
                ```ts
                // selector.ts
                const selectOpenAIChatModels = (state) => state.entities.openAIChatModels;

                // components.tsx
                const openAIChatModels = useSelector(selectOpenAIChatModels)
                ```
- 性能优化：
    - API：
        - 因为Redux封装好了，直接算就行
    - 手动预加载与懒加载
        - useEffect预加载
            - 手动import
            - 实现`.preload`
            ```ts
            function lazyWithPreload(loader) {
                let component = null;
                const promise = loader().then(module => {
                    component = module.default;
                });

                const LazyComponent = React.lazy(loader);

                LazyComponent.preload = () => promise; // 添加preload方法
                return LazyComponent;
            }

            // 使用lazyWithPreload
            const LazyComponent = lazyWithPreload(() => import('./LazyComponent'));

            // 预加载组件
            LazyComponent.preload();
            ```
    - 根据react原理优化
        - diff的假设
- 前端指标监控
    - 测试环境：Performance面板
        - 在隐身模式下打开 Chrome。隐身模式可确保 Chrome 以干净状态运行，例如浏览器的扩展可能会在性能评估中产生影响。
        - 在 DevTools 中，单击“Performance”选项卡，并进行一些基础配置（更多参考官方说明 (opens new window)）。
        - 按照提示单击记录，开始记录。进行完相应的操作之后，点击停止。
        - 当页面运行时，DevTools 捕获性能指标。停止记录后，DevTools 处理数据，然后在 Performance 面板上显示结果。
        
        - 查看 FPS 图表：当在 FPS 上方看到红色条形时，表示帧速率下降得太低，以至于可能损害用户体验。通常，绿色条越高，FPS 越高
        - 查看 CPU 图表：CPU 图表在 FPS 图表下方。CPU 图表的颜色对应于性能板的底部的 Summary 选项卡
        - 查看 火焰图：火焰图直观地表示出了内部的 CPU 分析，横轴是时间，纵轴是调用指针，调用栈最顶端的函数在最下方。启用 JS 分析器后，火焰图会显示调用的每个 JavaScript 函数，可用于分析具体函数
        - 查看 Buttom-up：此视图可以看到某些函数对性能影响最大，并能够检查这些函数的调用路径

        - Cumulative Layout Shift (CLS) 是衡量页面稳定性的一个指标，用于衡量页面在加载过程中出现的所有布局位移的累积值。CLS 值越小，表示页面加载过程中的布局位移越少，用户体验越好。
        - LCP
        - Layout是布局
    - 用户环境：
        - 路由监控访问路径
        - log的记录
    - SEO
        - 部分路由返回静态HTML
- 后端
    - SW在项目中的完整流程解说：
        1. 需求分析和系统设计
            - 目标：明确系统功能，如 AI 助手的问答功能、用户权限管理、聊天记录下载等。
            - 输出：简单的架构图表，代码架构图。
            - 数据库设计：设计知识库表结构；设计用户表，存储用户信息和权限。
            - API 设计：定义 RESTful API，如 /api/chat 用于聊天交互
        2. 编码与测试
            - 前端开发：使用 React 实现用户界面，包括聊天窗口、登录页面等。
            - 后端开发：实现 AI 助手数据流的核心逻辑，集成 Azure Services 进行自然语言处理。
            - 测试：建立本地测试环境；编写简易单元测试和集成测试
            - 安全性：使用 JWT 实现用户认证；参数化查询防止 SQL 注入；仅在 HTTPS 连接中发送 cookie，禁止 JavaScript 访问 cookie，防止跨站请求伪造 (CSRF)
        3. 版本控制
            - Git 使用：使用 Git 管理代码，创建分支开发新功能，合并到主分支后进行部署。
        4. 部署与运维
            - CI/CD：使用 Azure APP Service 持续集成和持续交付，自动化构建和部署。
            - 监控：使用 Azure APP Service 监控系统日志和性能
        5. 后续更新
            - 新功能：保持代码质量，保持弹性和可拓展性
            - 优化：前端和后端
        
        - 面试准备建议
            - 熟悉项目细节：清晰描述项目的每个阶段（需求分析、设计、开发、测试、部署）。
            - 掌握基础知识：复习软件工程的核心概念（如敏捷开发、CI/CD、版本控制）。
            - 准备技术问题：面试官可能会问具体技术问题（如 React 生命周期、Redux 工作原理、JWT 实现）。
            - 展示解决问题的能力：准备一些你在项目中遇到的问题和解决方案（如性能优化、Bug 修复）。
        
        - 示例面试回答
            - 面试官：请描述一下你在项目中的角色和贡献。你：我负责了从需求分析到测试上线的全流程开发。在需求分析阶段，我与学校教师和学生沟通，明确了 AI 助手的功能需求。在设计阶段，我选择了 MVC 架构，并使用 React 和 Node.js 实现了前后端。在开发阶段，我使用 Redux 管理状态，并通过 JWT 实现了用户认证和权限控制。最后，我使用 Azure DevOps 实现了 CI/CD，确保系统能够高效部署和运行。
    
    - Alibaba MVC架构，最重要的manager在项目中的应用
        - manager就是一些service的通用逻辑
        - 可以说一下我的理解：有一些逻辑并非service，且多个service都会使用，于是用manager封装。
    - 网关全局异常处理了解一下（也就是具体Quart是怎么实现这一点的）
        - 定义blueprint（也就是一组url），给blueprint挂载上errorhandler且指定特定error，把blueprint挂载上app，启动app
        - 具体有哪些error：todo
    - 延迟消息队列
        - 是什么？怎么减轻压力的？
            - 在一个独立的服务器上挂载，通过网络连接与生产者和消费者通信
            - 高可用性和持久化机制
            - 保证顺序
        - 具体实现是什么样的？
            - 生产者添加消息队列，消费者接收发布推送/长轮询
            - 接收信息时同步进行持久化
                - 磁盘、数据库、日志
            - 集群模式，节点只要一个可用，服务就不会停止
        - 为什么用MQ？
            - 解耦系统的组件，组件之间不需要通信，只要和消息队列打交道就行
            - 高负载场景的流量削峰
    - 本地缓存
        - 为什么要使用缓存？
            - 保存一些有一定生命周期的资源
                - email注册验证码
            - 减少sql访问压力、服务器计算与流量压力
                - openai_chat_model_cache
                - azure_openai_resource_cache
                - public_openai_assistant_cache
                - sketch_engine_resource_cache
    - JWT和权限控制
        - JWT主要储存id、email、role、和过期策略
        - email验证后发放，储存在localStorage中
        - exp是120天，logout就删除
        - 每次登录就刷新
    - 数据库设计
        - 把azure的instance封装了起来
        - ACID原则怎么体现的
            - CosmosDB在单分区下支持ACID
            - Atomicity：
                - 可以用batch operation，但没必要
                - 整个软件的设计就是一次更新事务不会涉及多次数据库更新操作（因为这个app并不复杂）
                - 唯一需要的就是transaction，但因为是内部教育用app，并不会有客户的充值内容，只有老师主动transfer credit，所以不太需要consistency
            - Consistency & Isolation：
                - 会话一致性，而single instance mode保证了只有一个会话
                - 所有的service都不会互相引用，因为特地设计过+有manager层
                - CosmosDB在单分区下支持ACID
            - Durability：
                - Azure对每一个node都会有三分copy，且RTO RPO为0
                - periodic backup 8 hours。Locally-redundant backup storage
        - 为什么选择CosmosDB
            - 客户的要求经常改变，NoSQL方便后续拓展
            - SQL需要很多前期设计，但NoSQL不需要。出于开发周期考虑用NoSQL。
            - SQL的场景需要强一致性，而这个app只是内部app并不需要强一致性
    - api设计
        - auth
        - transaction
        - users
        - ai_resource、model、assistant、thread
        - thread_run、message
        - store、store_file
        - sketch_engine_resource
    - 全局网关的error
        - api
            - value error 400
                - 主要是服务端数据库内容不匹配
            - token error 401
                - JWT验证token
            - 外部功能的error
                - sketch
                - Azure提供的ERROR
            - 测试用的error
        - public
            - 404
        - General
            - 500
    - 准备一些遇到的问题和解决方案
        - SQL to NoSQL
        - Multi-corpus：
            - 问题：
            - 思考过程：
            - 解决方案选择：
                - 采用了multi-agent flow
            - 反思
- `useMemo` 和 `useCallback`, `React.lazy` 和 `Suspense` 的动态路由加载
    - `useMemo`
        - 一个目标函数，一个依赖数组
        - 当依赖数组的值发生改变就会重新计算目标函数的返回值
    - `useCallback`
        - 缓存函数用的
        - 一个目标函数，一个依赖数组
        - 使用场景：
            - useEffect的依赖数组如果有函数，用useCallback的返回值来替代原本的函数能避免useEffect的错误触发（当然也可以直接用useEffect内的护卫语句来达到类似的效果）
            - 子组件使用了React.memo之类的优化方式时，useCallback可以缓存传入子组件的函数。
    - `React.lazy`
        - 接收一个thenable的函数，这个函数需要最终返回一个可以被解析为React组件类型的值，例如函数组件、memo或forwardRef 组件。lazy会抛出包裹这个值的Promise给Suspense捕获
        - import()
            - import()是个动态导入语法（Dynamic Import），返回`Promise<React组件>`，但解析后会成为组件
            - lazy依赖于import()
            - 用途：
                - 代码分割（Code Splitting）：将应用的代码拆分成多个小块，按需加载，减少初始加载时间。
                - 懒加载组件
                - 条件加载模块：根据某些条件（如用户权限、设备类型）动态加载模块。
                - 加载非模块代码，例如.json：`import("./data.json", { with: { type: "json" } });`
    - `Suspense`
        - 通过捕获children抛出的Promsie对象来判断要不要用fallback
        - suspense里面的代码thrown一个Promise并不会导致报错，只是简单地运行这个Promise并让Suspense捕获而已
        - 复习下scrollTop
            - 子元素的offsetTop和非static position的父容器的scrollTop对比下就能实现懒加载
            - offsetWidth包含padding不包含滚动条。scroll也只到padding不需要考虑滚动条
- 基于 SSE 的实时聊天交互、机器人回复的流式显示
    - 长连接，缓存块，pesudoMessage
- 自定义Hooks来抽象数据获取和表单处理逻辑，提升了代码的可读性和可维护性。
    - 为什么要自定义hook？
        - 复用、封装逻辑
        - 分离逻辑：把和UI没有直接关系的运算、数据获取逻辑全部封装成钩子，让组件只关心怎么用数据渲染UI，而不用理会数据的预处理
- 路由
    - 那你就要知道路由用纯JS怎么实现，监听hashChange和History API两种方式的话，又怎么写代码呢？
    - History API
        - `history.pushState({}, '', path);`：更改路径并跳转
            - history.pushState 接收三个参数：
            - state：一个状态对象，与新的 URL 关联。可以是任意可序列化的数据。
            - title：新页面的标题。目前大多数浏览器忽略此参数。
            - url：新的 URL。
        - `window.popstate`：监听 popstate 事件（浏览器前进/后退时触发）。
    - `hashchange`事件 & `window.onhashchange`
        - `window.location.hash`访问hash
        - `HashChangeEvent.newURL` 用事件来访问
            - 只读
            - 一个字符串，表示窗口导航到的新 URL。
        - `HashChangeEvent.oldURL` 用事件来访问
            - 只读
            - 一个字符串，表示导航窗口的上一个 URL。
        - eg
            ```ts
            function locationHashChanged() {
                if (location.hash === "#cool-feature") {
                    console.log("你正在访问一个很酷的功能！");
                }
            }
            window.onhashchange = locationHashChanged;
            // or
            window.addEventListener(
                "hashchange",
                (HashChangeEvent) => {
                    console.log("哈希已更改:", HashChangeEvent.newURL);
                },
                false,
            );
            ```
    - routePairs对象：保存路径与对应组件的关系，匹配到path就返回对应的组件
    - pathToRegex函数：解析路径与捕获参数。react的路径定义方法有些语法糖，比如`:id`要变成`"id": <value>`。需要分析哪一段是把接收的path的id捕获出来放进
    - matchPath函数：把输入的path解析并匹配，返回对应keys和components
    - render函数：清除现有DOM，挂载新DOM
    - navigate函数：`history.pushState({}, '', path);`后，render保存的对应组件
    - handleRouteChange函数：匹配当前`window.location.pathname`并渲染对应组件
    - 事件监听：
        - 在document监听`DOMContentLoaded`以首屏加载
        - 在window监听`popstate`
    - eg
    ```ts
    // 路由配置
    const routes = [
        { path: '/', component: Home },
        { path: '/about', component: About },
        { path: '/user/:id', component: User },
        { path: '*', component: NotFound } // 404 页面
    ];
    // 路径转正则表达式（简化版）
    function pathToRegexp(path, keys) {
        const pattern = path.replace(/:(\w+)/g, (_, key) => {
            keys.push({ name: key });
            return '([^\/]+)';
        });
        return new RegExp(`^${pattern}$`);
    }
    // 路由匹配
    function matchRoute(path, routes) {
        for (const route of routes) {
            const keys = [];
            const regex = pathToRegexp(route.path, keys);
            const match = regex.exec(path);

            if (match) {
                const params = keys.reduce((acc, key, index) => {
                    acc[key.name] = match[index + 1];
                    return acc;
                }, {});
                return { ...route, params };
            }
        }
        return null;
    }
    // 动态组件渲染
    function render(component, params) {
        const app = document.getElementById('app');
        app.innerHTML = '';
        const element = document.createElement('div');
        element.innerHTML = component(params);
        app.appendChild(element);
    }
    // 导航
    function navigate(path) {
        history.pushState({}, '', path);
        handleRouteChange();
    }
    // 处理路由变化
    function handleRouteChange() {
        const path = window.location.pathname;
        const matchedRoute = matchRoute(path, routes);

        if (matchedRoute) {
            render(matchedRoute.component, matchedRoute.params);
        } else {
            render(NotFound);
        }
    }
    // 初始化
    window.addEventListener('popstate', handleRouteChange);
    document.addEventListener('DOMContentLoaded', handleRouteChange);
    // 组件定义
    function Home() {return '<h1>Home</h1>';}
    // ...

    // 初始化渲染
    handleRouteChange();
    ```

### 八股
- 前端
    - css实现水平居中的方式，多说几种
        - margin: 0 auto;
        - jusitify-content: center;
        - trans
    - 如何清除浮动
        - 浮动元素前的块会顶开浮动元素，后的块则会被覆盖。
            - 当然如果float方向不会覆盖到后面的块自然不会影响显示后面的块，只是位置会不同：float被顶开的距离只会计算前面块，后面的块会被忽略
        - 设置块状clear的空后兄弟元素撑起父容器，具体left/right/both再判断
            - 伪元素`:after`、空div都可以
            - 注意clear的含义其实就是不允许某个方向上有人浮动，所以float的left和right与clear的left和right注意需要互相对着
                - 比如float在前且float:left，你后面的元素clear:right是没用的
                - 此外，因为float前的块会顶开float，对前块设置clear没用
        - 父级变成BFC
            - overflow不为visible
            - `display: flow-root`
            - 注意只能让父元素能够识别和包含浮动元素，float的后子元素仍然会被覆盖
    - 文字超出盒子的宽高，对其隐藏设置什么属性
        - white-space: nowrap; /* 禁止换行 */
        - overflow: hidden; /* 超出部分隐藏 */
        - text-overflow: ellipsis; /* 显示省略号 */
    - 如何解决塌陷问题：例如 父元素里有子元素，给子元素设置margin-top:50;父盒子和子盒子一块塌陷 
        - 隔离父盒子和子盒子
        - 父级变成BFC
    - ES6新特性有哪些
    - 说下原型链
    - 普通函数和箭头函数有什么区别
        - args、this、构造函数
    - 修改this的几种方式
        - 因为this的使用永远和函数或者方法有关，所以只考虑call apply bind就行
        - call：传入上下文和逐一传入参数并立刻运行
        - apply：传入上下文和参数数组并立刻运行
        - bind：绑定上下文和一部分参数并返回一个新函数。这个新函数的参数会优先接收绑定的参数再顺序接收调用传入的参数
    - sessionStorage和localStorage的区别
        - sessionStorage：
            - 生命周期：页面会话期间有效，关闭页面后数据被清除。
            - 作用域：仅在当前标签页有效。
        - localStorage：
            - 生命周期：永久存储，除非手动清除。
            - 作用域：跨标签页共享。
    - ts中type和interface的相同点
        - 定义类型：都可以用来定义对象、函数、类等的类型。
        - 扩展：都可以通过 extends 或 & 进行扩展。
        - 实现：都可以被类实现（implements）。
    - 懒加载
        - 关键在于进入点和停止监听点
        - 进阶一点就是懒加载用纯JS怎么实现
            - 子元素offsetTop < 父元素clientHeight + 父元素scrollTop
            - window.pageYOffset ? window.pageYOffset : window.document.documentElement.scrollTop
            - Intersection Observer API
                - eg
                    ```ts
                    const observer = new IntersectionObserver(entries => {
                        for (const i of entries) {
                            if (i.isIntersecting) { // 当目标元素出现在视图内
                                const img = i.target;
                                const trueSrc = img.getAttribute("data-src");
                                setTimeout(() => {
                                    img.setAttribute("src", trueSrc); // 方便展示懒加载效果
                                }, 1000);
                                observer.unobserve(img); // 停止监听此元素
                            }
                        }
                    });
                    ```
    - 说几条性能优化的方案
        - http请求减少、资源压缩
        - 按需加载
        - 服务端渲染
        - 防抖与节流
            - 防抖：短时间内多次，只算最后一次
            - 节流：短时间内多次，每一稳定时间区间只算一次
- 闭包原理、作用、应用场景
    - 保存状态：闭包可以保存函数执行时的状态，即使函数已经执行完毕。
    - 实现私有变量：通过闭包，可以模拟私有变量，避免外部直接访问和修改。
    - 延迟执行：闭包可以用于实现延迟执行（如回调函数、定时器）。
    - 模块化：闭包可以用于创建模块，封装私有方法和变量。
    - 需要注意的地方：
        - 解决闭包的引用错误问题：
            - 用立刻执行函数再包裹一层，把i传入立刻执行函数就能绑定好参数了
            - 用let在和函数同级的作用域中定义函数引用的变量，以此让外部的变化影响不了函数内
        - 箭头函数
            - 注意箭头函数在闭包中的this和最外层的func是同一个，因为这是箭头函数最基础的捕获上下文
- 前端安全
    - CSRF（Cross-Site Request Forgery）：
        - 恶意伪造请求
        - 攻击原理：诱导用户点击恶意链接，利用已登录的身份发起伪造请求（如转账）。
        - 就在目标站内生成恶意链接当然不行，但在其他地方比如email就可能会造成CSRF。
        - 防御方法：重点是防止跨站的请求
            - Token 验证：服务端生成随机 Token，前端提交时携带。
            - SameSite Cookie：设置 Cookie 的 SameSite 属性为 Strict 或 Lax。
            - 验证 Referer：检查请求来源是否合法。
    - XSS（Cross-Site Scripting）：
        - 恶意运行脚本
        - 攻击原理：向页面注入恶意脚本（如 JavaScript），窃取用户 Cookie 或篡改页面内容。
        - 分类：
            - 存储型 XSS：恶意脚本存储到数据库（如论坛评论），触发方式是被加载
            - 反射型 XSS：通过 URL 参数注入（诱导用户点击链接），触发方式是用户主动点击
            - DOM 型 XSS：前端 JavaScript 操作 DOM 时触发，具体来说是innerHTML被赋值时会运行其中的代码
        - 防御方法：
            - 输入过滤：对用户输入进行转义（如 < 转义为 &lt;）。
            - 输出编码：根据输出场景（HTML/JS/URL）使用不同编码库。
            - 设置 HTTP 头：Content-Security-Policy (CSP) 限制脚本来源。
- 计算机网络
    - 输入url发生什么
        - URL 解析：解析 URL，提取协议、域名、路径等信息。
        - DNS 解析：将域名解析为 IP 地址。
        - 建立 TCP 连接：通过三次握手建立连接，如果是 HTTPS 则进行 TLS/SSL 握手。
        - 发送 HTTP 请求：构造并发送 HTTP 请求。
        - 服务器处理请求：服务器处理请求并生成 HTTP 响应。
        - 接收 HTTP 响应：浏览器接收并解析 HTTP 响应。
        - 渲染网页：解析 HTML、CSS，构建 DOM 树和 CSSOM 树，生成渲染树，布局和绘制。
            - 解析 HTML：浏览器解析 HTML 文件，构建 DOM 树（Document Object Model）。
            - 加载外部资源：浏览器根据 HTML 中的标签（如 `<link>`、`<script>`、`<img>`），加载 CSS、JavaScript、图片等外部资源。
            - 解析 CSS：浏览器解析 CSS 文件，构建 CSSOM 树（CSS Object Model）。
            - 构建渲染树：浏览器将 DOM 树和 CSSOM 树合并，生成渲染树（Render Tree）。
            - 布局（Layout）：浏览器计算渲染树中每个节点的位置和大小（Layout 或 Reflow）。
            - 绘制（Paint）：浏览器将渲染树绘制到屏幕上（Paint）。
            - 执行 JavaScript：浏览器执行 JavaScript 代码，可能会修改 DOM 或 CSSOM，触发重新布局和绘制。
                - 网页交互：处理用户交互事件，动态更新页面。
                - 关闭连接：通过四次挥手关闭 TCP 连接。
                - 缓存：缓存静态资源，加速下次访问。
- 如何设计一个高并发的系统？
    - 分布式架构：
        - 水平扩展（如微服务、分片）。
        - 无状态服务（Session存储到Redis）。
    - 负载均衡：
        - 使用Nginx或HAProxy分发请求。
        - 一致性哈希分配流量。
    - 缓存：
        - 缓存热点数据（如Redis、Memcached）。
        - CDN加速静态资源。
    - 数据库优化：
        - 读写分离（主从复制）。
        - 分库分表（如ShardingSphere）。
    - 异步处理：
        - 消息队列（如Kafka）解耦请求。
        - 批量处理减少I/O次数。
    - 限流与熔断：
        - 令牌桶限流（如Guava RateLimiter）。
        - 熔断降级（如Hystrix）。
- 性能分析工具
    - CPU分析：统计耗时和使用率
    - 内存分析：检测泄露、统计使用率、统计转储文件
    - I/O分析：统计时间



# todo WIP
- Corpus的工程化优化：
    - splitChunk：
        - 把第三方库独立打包
        - 用动态导入分离模块+预加载
            - 每个懒加载组件生成独立的 chunk 文件（如 Home.chunk.js）。
            - `const Home = React.lazy(() => import(/* webpackPrefetch: true */ './Home'))`;
        - 合并小chunk
            optimization: {
                splitChunks: {
                    minSize: 20000, // 小于 20KB 不单独打包
                },
            }
    - 开发模式的行为
        - css-/style-loader
        - eval-source-map
        - DevServer for HMR
    - 生产模式的行为
        - Terser和MinimizeCSS的plugin
        - manifest.json
            - 作用：记录模块 ID 与生成文件（chunk）的映射关系。
            - 解决的问题：当应用代码更新时，通过 manifest 知道哪些 chunk 需要重新加载。
            - 长期缓存：即使业务代码变化，第三方库（如 react）的 chunk 哈希不变，可长期缓存。
            - 固定第三方库的哈希
                ```js
                optimization: {
                    moduleIds: 'deterministic', // 模块 ID 根据路径生成，内容不变则 ID 不变
                    chunkIds: 'deterministic'   // 同上
                }
                ```
- Corpus的redux优化
    - useSelector按需更新
    - 精细化state的selector
    - 生产环境禁用dev tool的历史记录
        ```js
        const store = createStore(
            reducer,
            process.env.NODE_ENV === 'production' 
                ? undefined 
                : window.__REDUX_DEVTOOLS_EXTENSION__?.()
        );
        ```
- 前端
    - css选择器优先级
        - 总顺序
            1. `!important`会覆盖页面内任何位置的元素样式，权值为正无穷
            2. 内联样式，如`style="color: green"`，权值为1000
            3. ID选择器，如`#app`，权值为0100
            4. 类、伪类、属性选择器，如`.foo`, `:first-child`, `div[class="foo"]`，权值为0010
            5. 标签、伪元素选择器，如`div::first-line`，权值为0001
            6. 通配符、子类选择器、兄弟选择器，如`*`, `>`, `+`，权值为0000
            7. 继承的样式没有权值
        - 权值计算：
            - 一行选择器的优先级 = ABCD
            - 如果存在内联样式，那么 A = 1, 否则 A = 0
            - B 的值等于 ID选择器出现的次数
            - C 的值等于 类选择器 和 属性选择器 和 伪类 出现的总次数
            - D 的值等于 标签选择器 和 伪元素 出现的总次数
            - eg `.main .123[class="foo"]`中，A=0，B=0，C=3，D=0，最终权值为0030
        - 权重相同的情况下，后者覆盖前者
        - 权值其实是256进制的
- 面经
    - 逻辑题就是脑筋急转弯
        - 可以多用数学的思维，比如符号标记啥的
        - 逆向思考：排除不对的答案
    - 场景题可以大刀阔斧地改
    - 先从简单的做起，进入状态
- 算法
    - 【解决】用中序和前序出tree
        1. 在中序数组找前序第一个元素，标记为pivot
        2. 中序pivot左边的子串是左子树，右边是右子树
        3. 在前序中找左右子树各自的对应子串（必然是子串，因为前序就是连续的）
        4. 用这俩子串分别再次回到第一步递归地找，最后完成
    - 【真的完全不会】字符串修改k次后的所有不重复可能性
        - 对一个长度为n的，只有小写字母的字符串进行k次修改，每次修改会将任意一个位置的字符修改为与当前字母不一样的另一小写字母。求k次修改后，所有unique字符串的数量
    - 【大致解决】divisible by k的子串的和
        - 前缀和+在循环中动态计算和判断sum
    - 【大致解决】时间回文：找出需要经过多少时间才能出现一个时间回文，即小时和分钟互为对方的相反
        - 其实应该已经解决了
    - 【解决】给定入栈出栈顺序，其中包含两个相邻操作被对调了，找出对调的操作。
        - 其实就是模拟
    - 【大致解决】演奏方法的所有组合（固定条件下的子串分组）
        - dp
- network
    - 【解决】路由器、交换机的所有知识
	    - 路由器转发分组的储存转发机制
        - 路由器会选择哪个分组先：最长前缀
    - 【大致解决】计算机网路各层的协议
        - UDP、FTP、ARP、DHCP
        - HDLC协议
        - TCP协议中的停止等待协议
        - SSL Telnet、PPTP、PGP、IP
    - 【大致解决】ip掩码长度
    - 【大致解决】TCP除了等待停止协议还有什么协议？
- OS
    - 【大致解决】采用最佳适应算法下的内存分配
    - 【大致解决】sys failure的定义
    - 【大致解决】12 platters（什么叫最外围不可用？）、100tracks、12sectors、521 bytes，最大容量
    - 【大致解决】盘片一定是双面都可以用吗？
    - 【解决】RAM用direct insert时，最坏情况下对比几次？
        - direct Map，如果index一样但tag不匹配就会对比n-1次
    - 【大致解决】average turnaround time，3h 2h 4h的顺序
- 硬件都来了
    - 【解决】基带和频带
    - 【解决】比特率和波特率
- general
    - AI的影响
        - AI边缘
            - 私有数据训练的道德规范
            - 新兴技能需求
                - 提示工程（Prompt Engineering）成为必备技能
                - AI生成内容的审查与质量控制
                - 人机协作开发模式规范制定
                - AI协作能力，无论IDE工具还是聊天机器人
            - 商业模式创新
                - 按需算力租赁（处理超大型文档分析）
        - AI核心
            - 智能生产力工具
                - 生成稿件、代码、文档
                - 个性化助手服务
                - 行业垂直解决方案（教育/医疗专用模板引擎）
            - 生产力提升工具（工作流加速）
                - 多语言实时协作（自动翻译保持格式）
                - 将自动化拓展到人文领域：合规性自动检查（法律/财务文档风险识别）
                - 会议录音→结构化笔记自动生成
            - 交互体验提升
                - 以非文字方式访问数字世界，例如手势、语音
                - 多模态：语音、视觉、文字混合交互，例如让ai根据图片和说的内容生成内容
                - 逻辑简化：简化交互逻辑，把更复杂的内容交给ai处理
            - 知识管理革命
                - 让AI组织和筛选杂乱的信息
                - 知识检索可以更加高效自由，如跨语言检索、快速筛选等
    - 解决问题的方法论
        - 前
            - 资源利用
                - 团队协作：组织代码审查或头脑风暴会议
                - 外部资源：查阅Stack Overflow、官方文档、技术博客、相关论文或开源项目类似实现
            - 更改方案
                - 评估是否有替代方案可以绕过该问题
                - 考虑是否可以通过重构简化问题
                - 必要时与利益相关者沟通调整需求
            - 问题分析与拆解
                - 重新分析问题：用不同方式表述问题，确认真正痛点
                - 分解问题：将大问题拆分为可管理的小模块（如使用分治法）
                - 绘制流程图：可视化问题场景和数据流
        - 中
            - 技术解决策略
                - 多角度验证：尝试不同的算法/架构方案
                - 原型验证：为可能的解决方案构建最小可行原型
                - 日志与调试：增加详细日志，使用条件断点调试
            - 心态与时间管理
                - 适当休息：通过休息获得新视角（如橡皮鸭调试法）
                - 设定里程碑：将长期问题分解为阶段性目标
                - 记录过程：保持详细的问题解决日志
- 腾子的面经
    - 你认为为什么要学习前端框架/引擎的底层原理？
        - 复杂bug的解决
        - 深入到底层的性能优化
        - 可以自定义拓展高级功能
        - 对框架的深入理解有助前期技术选型。
        - 新技术的学习路线更平缓（因为很多技术都是从现有技术慢慢迭代的）


八股：
浏览器渲染流程是什么？能怎么被利用？
    优化关键渲染路径：
        缩短关键路径长度（减少渲染阻塞）
    减少重排重绘：
        使用transform/opacity等属性触发合成层
        批量DOM操作、DocumentFragment
        使用will-change提示浏览器优化
        合理使用requestAnimationFrame

事件循环能解决什么场景的问题？为什么要设计宏任务和微任务？要怎么平衡宏任务和微任务的使用？
    事件循环解决的问题：
        单线程处理多任务：JavaScript是单线程的，事件循环机制使得异步操作成为可能
        非阻塞I/O：允许在等待I/O操作时执行其他任务
        任务优先级管理：通过宏任务和微任务区分任务优先级
    注意，事件循环在浏览器应该是运行js的那一步，所以事件循环要能开始，必须要浏览器主线程也空闲了才行，比如渲染完了页面

宏任务和微任务设计原因：
    任务优先级：微任务优先级高于宏任务，保证某些高优先级任务能及时执行
    IO操作和UI渲染也在宏任务内，
    平衡使用建议：
        关键更新使用微任务：如状态更新、DOM变更等需要及时反映的操作
        耗时操作使用宏任务：如大数据处理、复杂计算等，避免阻塞UI更新
        避免微任务嵌套过深：可能导致页面卡顿

浏览器每一帧中的行为
- 浏览器事件循环
    - 检查并执行最老的可执行宏任务
    - 每个宏任务（注意不是清空队列，而是每个任务）结束后尝试清空微任务队列
    - 根据一定准则决定要不要触发渲染
        - 遍历当前浏览上下文中所有的 document ，必须按在列表中找到的顺序处理每个 document 。
        - 判断渲染时机（Rendering opportunities）：
            - 根据硬件刷新率限制、页面性能或页面是否在后台等因素。
            - 不必要的渲染（Unnecessary rendering）：如果浏览器认为不会产生可见效果则取消渲染
            - 有没有**rAF**，没有则取消渲染（也是因此使用rAF可以实现更丝滑的动画/动态显示效果）
        - 处理各种事件（window.performance.now() 是一个时间戳，供浏览器计算剩余时间判断应不应该继续把任务放入执行栈）
            - 处理 resize 事件，传入一个 performance.now() 时间戳。
            - 处理 scroll 事件，传入一个 performance.now() 时间戳。
            - 处理媒体查询，传入一个 performance.now() 时间戳。
            - 运行 CSS 动画，传入一个 performance.now() 时间戳。
            - 处理全屏事件，传入一个 performance.now() 时间戳。
        - 执行回调
            - 执行 **requestAnimationFrame** 回调，传入一个 performance.now() 时间戳。
            - 执行 intersectionObserver 回调，传入一个 performance.now() 时间戳。
        - 对每个 document 进行绘制，更新UI呈现。
    - 看下该不该执行IdleCallback
    - 回到第一步继续循环

- requestIdleCallback：
    - 用于不重要也不紧急的任务，因为只有在每一帧时间有剩才运行这个callback
    - 且最长只会分配50ms
    - 可以接受第二个参数代表最长等待时间，超过了就强制执行
    - 以下例子展示了基础使用语法和结合timeout的用法
        ```js
        requestIdleCallback(myNonEssentialWork, { timeout: 2000 });

        function myNonEssentialWork(deadline) {
            // 当回调函数是由于超时才得以执行的话，deadline.didTimeout为true
            // requestIdleCallback调用回调的条件可以模拟为以下代码：
            // if ( (deadline.timeRemaining() > 0 || deadline.didTimeout) )
            if (tasks.length > 0 ) doOneWorkIfNeeded();
            // 对于比较长的任务，可以再次继续等待
            if (tasks.length > 0) { requestIdleCallback(myNonEssentialWork); }
        }
        ```
    - 常见使用场景：数据上报；不要用来修改DOM，因为只有重排重绘完了还有空才会idlecallback，改了DOM就直接作废了前面的操作
    - eg
        ```js
        function schedule() {
            requestIdleCallback(deadline => {
                while (deadline.timeRemaining() > 1) {
                    const data = queues.pop();
                    // 这里就可以处理数据、上传数据
                }
                if (queues.length) schedule();
            });
        }
        ```

- js的动画一般怎么实现的？比如常见的动画库是怎么画动画的？
    - 常用方法
        - rAF+css transform
            - transition：简单过渡效果
            - animation/@keyframes：复杂动画序列
            - transform/opacity：硬件加速，性能最佳
        - Web Animations API
    - 常见动画库实现原理：
        - GSAP：
            - 使用rAF实现高性能动画
            - 复杂的时间轴控制
            - 硬件加速优化
        - Anime.js：
            - 基于CSS transform和rAF
            - 支持SVG动画
        - Three.js（3D动画）：
            - 基于WebGL
            - 使用requestAnimationFrame实现流畅渲染
    - 最佳实践：
        - 优先使用CSS动画实现简单效果
        - 复杂动画使用rAF+transform/opacity
        - 避免在动画中触发重排
        - 使用will-change提示浏览器优化
项目：
react router的底层有什么样的优化？有没有按需加载的机制？
    - 似乎没有，但可以用createBrowserRouterAPI更优雅地设置该不该懒加载（手动封装好）
多页应用怎么实现相互的通信/信息整合？（类似微前端的场景）
- URL参数传递：
    - 通过query string或hash传递数据
- localStorage/sessionStorage配合storage事件监听变化
- BroadcastChannel API：
    // 页面A
    const channel = new BroadcastChannel('app-channel');
    channel.postMessage(data);
    // 页面B
    const channel = new BroadcastChannel('app-channel');
    channel.onmessage = (e) => { /* 处理数据 */ };
- window.postMessage：
    // 父窗口
    childWindow.postMessage(data, origin);
    // 子窗口
    window.addEventListener('message', (e) => {
    if (e.origin === expectedOrigin) {
        // 处理数据
    }
    });
- SharedWorker：
    适合复杂场景的跨页面通信
    所有页面通过worker进行数据同步
- iframe桥接（微前端常用）：
    主应用和子应用通过iframe通信
    使用window.parent和contentWindow通信



MessageChannel

场景题：
共享文档某个操作导致页面卡顿，问为什么卡顿，怎么解决
DOM操作过多：频繁的DOM更新导致重排/重绘
- 同步阻塞：
    - 大量同步数据阻塞主线程
    - 文档操作的算法效率低（如O(n²)复杂度）
    - 未使用虚拟化技术处理大文档
- 内存泄漏：
    - 未清理的引用导致内存占用过高
    - 事件监听过多
- 解决方案：
    - 优化DOM操作：
        - 使用文档片段(DocumentFragment)批量更新
        - 虚拟DOM或增量更新策略
        - 使用requestAnimationFrame调度渲染
    - 数据优化：
        - 使用差分算法只同步变化部分
        - Web Worker处理复杂计算
        - 节流/防抖高频操作
    - 性能分析工具：
        - 使用Chrome DevTools的Performance面板分析瓶颈
        - Memory面板检查内存泄漏
    - 虚拟化渲染：
        - 只渲染可视区域内的文档内容
        - 使用react-window或react-virtualized等库
    - WebAssembly加速：
        - 对性能关键路径使用Wasm实现

8. 共享文档要有哪些/要怎么识别和解决可能的性能问题？
需要关注的性能问题：
渲染性能：
大量DOM节点导致的渲染延迟
复杂样式计算
协同编辑性能：
多人同时编辑时的冲突解决效率
操作转换(OT)或CRDT算法的实现效率
网络性能：
频繁的网络同步导致的延迟
未优化的数据传输格式
内存使用：
文档历史版本的内存占用
未清理的事件监听器
识别方法：
性能监控：
使用Performance API进行指标采集
关键用户操作的可交互时间(TTI)监控
压力测试：
模拟多用户同时编辑场景
大数据量文档操作测试
运行时分析：
Chrome DevTools的Performance记录
Memory堆快照分析
解决方案
架构优化：
采用增量更新策略
实现操作压缩/批量处理
数据优化：
使用二进制格式(如Protocol Buffers)减少传输数据量
差分同步代替全量同步
渲染优化：
实现画布(Canvas)渲染代替DOM渲染
按需渲染(虚拟滚动)
缓存策略：
本地操作缓存
离线编辑支持
代码优化：
避免同步阻塞操作
使用Web Worker处理后台任务
监控系统：
建立性能指标报警机制
用户行为轨迹记录分析性能瓶颈


# todo
- 算法
    - 最大团问题
    - 给定一堆区间，给出有多少区间的两两组合符合以下条件：max(l) <= min(r)
    - 排序算法
        - 归并
        - 快速
        - 桶
    - 哈希冲突解决算法
    - 给定完全二叉树的叶节点数量、该二叉树的总节点数量最多/最少是多少？
    - 给定无向图G = {V, E}，深度优先遍历可能得到哪些序列？
- 前端开发
    - 前端性能优化
        - 项目怎么优化的，具体数据？
        - general优化+浏览器层面优化
        - 频繁更新的可视化数据要怎么优化
            - 最小化更新+节流？
        - Performance API
    - react架构还没学完
    - 浏览器基础API
    - 浏览器渲染流程
    - 看chrome里保存的书签
    - SEO基础：配合SEO优化页面结构、标签、内容等
    - SSR底层原理：水和是啥，怎么实现的
    - 迭代器
    - redux的store中间件
    - ts
        - 泛型T
        - xxx?: yyy是 | undefined的语法糖吗？
        - react常用的type
    - px和rem和真实像素
    - 对AI输出有没有什么亮点和优化
    - v8的隐藏类是什么
    - Redux
        - createApi、enhanceEndpoint、injectEndpoint、build、query、mutation
        - configureStore
    - ajax
    - 实际应用下的防抖函数（state的改变可能检测不到）
    - 实现一个modal
    - 实现一个下拉框（absolute）（为什么float不行？）
- Network
    - HTTPS能防以下什么：hijacking、XSS、Dos、
    - TCP可靠传输协议：滑动窗口咋就可靠了
    - SSE和Websocket：属于计网哪一层、背后用什么协议来实现的
- OS
    - 容器与虚拟机是什么，有什么区别
    - utf-8编码
    - 系统的进程调度机制
    - 假设你有一台内存4g硬盘50g的服务器，最多可以接收多少tcp连接。如果内存满了如何利用硬盘的空间。
    - 解释文件系统的层次结构。
- SQL
    - 常见命令
    - 数据库的索引及其优缺点是什么？请举例说明
    - 慢查询
    - 优化
- general
    - 模块的解耦程度
    - class diagram的+，-，#的含义
    - 你觉得自己的优势在哪里，语言，操作系统，还是什么？


如果有基础的话，可以试试更进阶的，比如 Codeforces 上面的div 2，可以给自己开virtual participation，如果2h的比赛可以稳定独立做出3~4个题，笔试和面试阶段的算法题应该不会难住你了。

# company target
- Tech
    - international
        - Microsoft
        - Google
        - Meta
    - Mainland
        - 华为
        - 阿里
        - 字节
        - 大疆
        - 腾讯
        - 宁德时代
        - 比亚迪
        - 科大讯飞
        - 网易
        - 美团
        - 蚂蚁
        - mihoyo
        - 小米
        - 百度
- Bank/finance
    - Accture
    - Jane street
    - big four: Deloitte, PWC, EY, KPMG
    - banks: HSBC, Bank of China
    - morgan stanley


