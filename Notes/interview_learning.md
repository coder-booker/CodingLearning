### How to solve customers complaint
- Stay Calm and Empathetic
    - 说明一些聆听技巧、阅读技巧之类的
- Identify the Root Cause: 
    - Highlight your problem-solving skills by ***discussing how you investigate the underlying issue.*** 
    - Mention specific techniques like asking ***clarifying questions or reviewing relevant data*** to pinpoint the problem.
    - try to describe the problem in a specific and ***structured*** way
- Offer Solutions: 
    - Describe how you ***present options*** to the customer and ***involve them in the decision-making process*** to ensure their satisfaction.
    - 必要时可以提供***补偿***或者临时方案
- Follow Up: 
    - Emphasize the importance of follow-through. Explain ***how you check back with the customer*** after resolving their complaint to ensure the solution was effective and to reinforce their trust in your service.
- Learn and Improve: 
    - Illustrate your commitment to continuous improvement by discussing ***how you analyze complaints to identify patterns and implement changes.*** Mention how you use feedback to enhance your approach and prevent future issues

### How to Trouble-shooting
- There are common steps: 
    1. identify the situation/context
    2. identify the problem
    3. brainstorm some solutions
    4. evaluate them and pick the best one
    5. implement
    6. evaluate the result

### career goal
- be specific. 
- eg: 
    - 我的短期目標是為一家***前景看好、能提供訓練課程和升遷機會***的公司工作。
    - 我的長期目標是在***加強解決問題的能力和人際技巧***的同時，***累積其他行銷相關經驗***。

### 你想通过这份工作得到什么？
- 和短期目标有点像，但需要和该工作更相关的回答

### What do you know about us
- 了解公司背景、行业背景、工作要求，以及这三者如何互相影响
- 还可以带上“因为我想追求xxx的目标和贵公司重合”

### Do you any questions?
- 重点。通过详细询问工作待遇和工作内容可以判断这家公司是否有雷。
- 工作待遇：
    - 实际薪资（排除五险一金/强积金），何时发放
    - 双休，工作时间
    - 加班补贴
- 工作内容：
    - 有无培训，有无人带
    - 内部架构，直属部门，具体工作内容（日常、项目工作等）
    - 直属领导






# Linkedin
### Profile
- headline【done】

- banner【done】

- pronounciation【done】

- About【done】
    - 一些准则
        - 可以讲下故事
        - 不要用奇怪的术语
        - 头三行算是重点，决定别人想不想继续看下去
    - 思考
        - 我真正想要的是什么？追求任何形式的欢愉，在一切之中找乐子。
            - 为此我可以提及：我愿意尝试新的东西和挑战，只是为了在其中找到乐趣
            - 这个也可以和我说“正在gap year寻求新的机会”这一目标相似，可以通过“新”这个元素融合
            - 例子就说：我在做parttime工作，领域是我毫无经验的语言学
            - 然后再说我接受任何形式的新挑战，并尝试结合我的专业只是来解决问题
        - 打游戏？爱好真的应该写进去吗？
        - 但谨记，我是为了找工作和connection。
    - 一些已经有的思路
        - 我觉得还是必须声明我在寻求更进一步的新发展，并且甚至为此申请了gap year
        - 然后提及我gladly喜欢尝试新的东西和挑战，只是为了在其中找到乐趣
            - 这个也可以和我说“正在gap year寻求新的机会”这一目标相似，可以通过“新”这个元素融合
            - 例子就说：我在做parttime工作，领域是我毫无经验的语言学
            - 然后再说我接受任何形式的新挑战，并尝试结合我的专业只是来解决问题
    - 最终script
    ```
    我一直以来都在尝试通过学习技术来得到成功，但随着时间的发展，我发现想要成为一名好的程序员，就必须不止步于程序员。为了探索和实现这个目标，我从我的大学中申请了一年的gap year，并在积极地寻找新的挑战，或者说机会。

    我曾认为代码这个工具能够解决任何问题，并一门心思深入其中。我曾与团队合作为初创公司构建网站，也于中国银行这类巨型企业做过实习。但我逐渐发现代码的局限性：电脑之外的世界太过复杂，哪怕最先进的AI也不是全知全能，总有些问题是我身为单纯的程序员无法解决的。于是我开始放眼更广泛的机会。在gap year中，我正在为大学兼职开发和维护一个语言学结合AI分析的聊天机器人平台。我从未接触过语言学，所幸我一直乐于学习新的事物--你总能在挑战中找到不为人知的乐趣。目前这个平台已经上线数月，供教师作教学用途，而我也学习到面对新挑战的乐趣，让我的gap year有了些许价值。
    
    我仍然热爱科技，但我会更加积极地向全新的领域开拓，并将我的技术发挥在更多方面上。在gap year中，我在积极地寻找长期的实习科技岗位，让我能通过更长地实习周期来学习更广泛的知识。如果你缺少一位愿意接受挑战的人，随时联系我

    I have always strived for success through learning technology, but over time, I realized that to become a great programmer, one must go beyond just coding. To explore and achieve this goal, I took a gap year from my university and am actively seeking new challenges and opportunities.

    I once believed that coding could solve any problem and dedicated myself to it. I have collaborated with teams to build websites for startups and interned at large corporations like the Bank of China. However, I gradually discovered the limitations of coding: the world outside computers is too complex, and even the most advanced AI is not omniscient. There are always problems that a mere programmer cannot solve. So, I began to look for broader opportunities.

    During my gap year, I have been part-time developing and maintaining a chatbot platform that combines linguistics with AI analysis for my university. Although I had no prior experience with linguistics, I have always enjoyed learning new things—you can always find hidden joys in challenges. This platform has been live for several months now, serving as a teaching tool for educators, and I have found value in my gap year through the joy of facing new challenges.

    I still have a passion for technology, but I am now more actively exploring new fields and applying my skills in various areas. During my gap year, I am actively seeking long-term tech internships that will allow me to learn a broader range of knowledge over an extended period. If you need someone who is willing to take on challenges, feel free to contact me.
    ```
    - 个人网站感觉也可以抽时间上一上

### connection
- 思路
    - 目的是有了connection之后，我可以得到更多职场知识，且对方更了解我一点了可以帮忙refer或者内推
    - 所有这个时候就有了两点需要注意：
        - 我想要知道什么职场知识？（这点需要因人而异，感觉就是直接搜索connection对象做过的工作、结合自己的情况问一下）（这点可以搜索一下“networking问啥问题比较好”）
        - connection对象是否合适？也就是我们要找谁做connection呢？
            - 1. 申请的公司的职员
            - 2. 和自己经历相似的人
            - 3. 只要是校友都可以connect一下
            - 4. 随机connect，比如曾经见过的人，讲师啥的。
        - 结论：refer可能没那么来得及，所以就以单纯的network和问职场经验为主吧
    - template
        - 
- target
- problem
    - career advice

# company target
- Tech
    - international
        - Microsoft
        - Google
        - Meta
    - Mainland
        - 华为
        - 阿里
        - 字节
        - 大疆
        - 腾讯
        - 宁德时代
        - 比亚迪
        - 科大讯飞
        - 网易
        - 美团
        - 蚂蚁
        - mihoyo
        - 小米
        - 百度
- Bank/finance
    - Accture
    - Jane street
    - big four: Deloitte, PWC, EY, KPMG
    - banks: HSBC, Bank of China


# Interview prepare
### introduce myself

### CorpusChat
- why Python but nodejs? 
    1. py开发效率高
    2. 客户要求
    3. Azure的openai assistant功能并没有nodejs的SDK
- technical difference btw python and nodejs
    - nodejs:
        - 基于事件驱动和非阻塞 I/O 模型，适合处理**I/O 密集型任务**（如文件操作、数据库查询）和**网络实时应用**（如 WebSocket、SSE）。
        - 单语言全栈开发，减少上下文切换
        - 生态系统统一且丰富（如 Express、NextJS 框架），工具链完整。
        - 社区活跃，更新频繁，支持现代开发实践。
        - 启动速度快，资源占用较少，适合微服务架构和 Serverless 场景。
        - **单线程模型**在处理 CPU 密集型任务（如复杂计算、图像处理）时性能较差。
            - 虽然可以通过 worker_threads 实现多线程，但复杂度较高。
    - python:
        - Python语法简洁，适合中小型项目或需要**快速迭代**的场景
        - 生态系统丰富
        - Python在算法实现和数据处理方面表现优异，如数据科学、机械学习等。
        - 更好的多线程和多进程支持，适合处理 CPU 密集型任务。
            - 但GIL（全局解释器锁）限制了多线程性能，需要asyio解决
        - Python是**解释型语言**，执行效率较低，不适合高并发或实时性要求高的场景。
            - 但可以通过多进程或异步编程（如 asyncio）优化。
        - Python 的异步性能和事件驱动机制不如 Node.js，不适合开发实时应用（如 WebSocket、SSE）。
- 后端
    - SW在项目中的完整流程解说：
        1. 需求分析和系统设计
            - 目标：明确系统功能，如 AI 助手的问答功能、用户权限管理、聊天记录下载等。
            - 输出：简单的架构图表，代码架构图。
            - 数据库设计：设计知识库表结构；设计用户表，存储用户信息和权限。
            - API 设计：定义 RESTful API，如 /api/chat 用于聊天交互
        3. 编码与测试
            - 前端开发：使用 React 实现用户界面，包括聊天窗口、登录页面等。
            - 后端开发：实现 AI 助手数据流的核心逻辑，集成 Azure Services 进行自然语言处理。
            - 测试：建立本地测试环境；编写简易单元测试和集成测试
            - 安全性：使用 JWT 实现用户认证；参数化查询防止 SQL 注入；仅在 HTTPS 连接中发送 cookie，禁止 JavaScript 访问 cookie，防止跨站请求伪造 (CSRF)
        4. 版本控制
            - Git 使用：使用 Git 管理代码，创建分支开发新功能，合并到主分支后进行部署。
        5. 部署与运维
            - CI/CD：使用 Azure APP Service 持续集成和持续交付，自动化构建和部署。
            - 监控：使用 Azure APP Service 监控系统日志和性能
        6. 性能优化
            - 前端优化：使用 React.lazy 和 Suspense 实现动态加载；状态管理方案升级为Redux
            - 后端优化：本地缓存常用数据，实现简易消息队列
        
        - 面试准备建议
            - 熟悉项目细节：清晰描述项目的每个阶段（需求分析、设计、开发、测试、部署）。
            - 掌握基础知识：复习软件工程的核心概念（如敏捷开发、CI/CD、版本控制）。
            - 准备技术问题：面试官可能会问具体技术问题（如 React 生命周期、Redux 工作原理、JWT 实现）。
            - 展示解决问题的能力：准备一些你在项目中遇到的问题和解决方案（如性能优化、Bug 修复）。
        
        - 示例面试回答
            - 面试官：请描述一下你在项目中的角色和贡献。你：我负责了从需求分析到测试上线的全流程开发。在需求分析阶段，我与学校教师和学生沟通，明确了 AI 助手的功能需求。在设计阶段，我选择了 MVC 架构，并使用 React 和 Node.js 实现了前后端。在开发阶段，我使用 Redux 管理状态，并通过 JWT 实现了用户认证和权限控制。最后，我使用 Azure DevOps 实现了 CI/CD，确保系统能够高效部署和运行。
    
    - Alibaba MVC架构，最重要的manager在项目中的应用
        - manager就是一些service的通用逻辑
        - 可以说一下我的理解：有一些逻辑并非service，且多个service都会使用，于是用manager封装。
    - 网关全局异常处理了解一下（也就是具体Quart是怎么实现这一点的）
        - 定义blueprint（也就是一组url），给blueprint挂载上errorhandler且指定特定error，把blueprint挂载上app，启动app
        - 具体有哪些error：todo
    - 延迟消息队列
        - 是什么？怎么减轻压力的？
            - 在一个独立的服务器上挂载，通过网络连接与生产者和消费者通信
            - 高可用性和持久化机制
            - 保证顺序
        - 具体实现是什么样的？
            - 生产者添加消息队列，消费者接收发布推送/长轮询
            - 接收信息时同步进行持久化
                - 磁盘、数据库、日志
            - 集群模式，节点只要一个可用，服务就不会停止
        - 为什么用MQ？
            - 解耦系统的组件，组件之间不需要通信，只要和消息队列打交道就行
            - 高负载场景的流量削峰
    - 本地缓存
        - 为什么要使用缓存？
            - 保存一些有一定生命周期的资源
                - email注册验证码
            - 减少sql访问压力、服务器计算与流量压力
                - openai_chat_model_cache
                - azure_openai_resource_cache
                - public_openai_assistant_cache
                - sketch_engine_resource_cache
    - JWT和权限控制
        - JWT主要储存id、email、role、和过期策略
        - email验证后发放，储存在localStorage中
        - exp是120天，logout就删除
        - 每次登录就刷新
    - CSRF之类xxx only的内容
        - httponly, samesite, secure
    - 数据库设计
        - 把azure的instance封装了起来
        - ACID原则怎么体现的
            - CosmosDB在单分区下支持ACID
            - Atomicity：
                - 可以用batch operation，但没必要
                - 整个软件的设计就是一次更新事务不会涉及多次数据库更新操作（因为这个app并不复杂）
                - 唯一需要的就是transaction，但因为是内部教育用app，并不会有客户的充值内容，只有老师主动transfer credit，所以不太需要consistency
            - Consistency & Isolation：
                - 会话一致性，而single instance mode保证了只有一个会话
                - 所有的service都不会互相引用，因为特地设计过+有manager层
                - CosmosDB在单分区下支持ACID
            - Durability：
                - Azure对每一个node都会有三分copy，且RTO RPO为0
                - periodic backup 8 hours。Locally-redundant backup storage
        - 为什么选择CosmosDB
            - 客户的要求经常改变，NoSQL方便后续拓展
            - SQL需要很多前期设计，但NoSQL不需要。出于开发周期考虑用NoSQL。
            - SQL的场景需要强一致性，而这个app只是内部app并不需要强一致性
    - api设计
        - auth
        - transaction
        - users
        - ai_resource、model、assistant、thread
        - thread_run、message
        - store、store_file
        - sketch_engine_resource
    - 全局网关的error
        - api
            - value error 400
                - 主要是服务端数据库内容不匹配
            - token error 401
                - JWT验证token
            - 外部功能的error
                - sketch
                - Azure提供的ERROR
            - 测试用的error
        - public
            - 404
        - General
            - 500
    - 准备一些遇到的问题和解决方案
        - SQL to NoSQL
        - Multi-corpus：
            - 问题：
            - 思考过程：
            - 解决方案选择：
                - 采用了multi-agent flow
            - 反思
- 前端(todo)
    - 将状态管理从 React Context 迁移到 Redux，利用 Redux Thunk 封装异步请求
        - 事实上react自己就有useReducer的钩子
            - 但很多东西都需要自己手动定义，例如action的type
            - redux还封装好了全局的state，而非仅当前组件内的state
        - 用action承载用以更改的数据，在reducer中把action里的数据更新到state中并通过selector广播
        - Slice：
            - name、initial state、reducers、extraReducers
            - name就是这个slice中所有同步action的type 前缀，后缀则是reducer的名字。
            - createSlice：reducer、action、action creator的语法糖
            - extraReducers：处理异步thunk的状态
                - 内置一些常用的一部状态，包括pending、fulfilled、rejected
        - Thunk：
            - 第一个参数是action type前缀。至于后缀则是thunk名
            - 第二个参数是一些给thunk用的redux API
                - 因为异步操作的复杂性，它的处理都是独立于其他同步reducer的，state也只能通过api获得。
            - 调用就是直接用thunk，但传入的参数会被传给第二个定义时的函数。
                - eg
                    ```ts
                    // incrementAsync(123)就是给amount传入123
                    export const incrementAsync = createAsyncThunk(
                        'counter/incrementAsync',
                        async (amount, { dispatch, getState, rejectWithValue }) => {
                            // 模拟异步操作
                            await new Promise((resolve) => setTimeout(resolve, 1000));
                            dispatch(incrementByAmount(amount)); // 调用同步Action
                        }
                    );
                    ```
        - Store
            - 注册reducer、state、和他们的关系，让redux知道有哪些reducer和state被定义了，以及配置它们的对应关系，让reducer只会接到一小段配置给它的子state
            - store提供dispatch。每次dispatch都会遍历注册的reducer，让输入的action能找到其匹配的reducer
        - Selector
            - 使用useSelector从store中提取状态（如count和status）。
            - 得配合定义好的selector才能暴露给组件使用
                - eg
                    ```ts
                    // selector.ts
                    const selectOpenAIChatModels = (state) => state.entities.openAIChatModels;

                    // components.tsx
                    const openAIChatModels = useSelector(selectOpenAIChatModels)
                    ```
    - useMemo 和 useCallback, React.lazy 和 Suspense 的动态路由加载
        - useMemo
            - 一个目标函数，一个依赖数组
            - 当依赖数组的值发生改变就会重新计算目标函数的返回值
        - useCallback
            - 缓存函数用的
            - 一个目标函数，一个依赖数组
            - 使用场景：
                - useEffect的依赖数组如果有函数，用useCallback的返回值来替代原本的函数能避免useEffect的错误触发（当然也可以直接用useEffect内的护卫语句来达到类似的效果）
                - 子组件使用了React.memo之类的优化方式时，useCallback可以缓存传入子组件的函数。
        - React.lazy
            - 接收一个thenable的函数，这个函数需要最终返回一个可以被解析为React组件类型的值，例如函数、memo或forwardRef 组件。lazy会抛出包裹这个值的Promise给Suspense捕获
            - import()
                - import()是个动态导入语法（Dynamic Import），返回`Promise<React组件>`，但解析后会成为组件
                - lazy依赖于import()
                - 用途：
                    - 代码分割（Code Splitting）：将应用的代码拆分成多个小块，按需加载，减少初始加载时间。
                    - 懒加载组件
                    - 条件加载模块：根据某些条件（如用户权限、设备类型）动态加载模块。
                    - 加载非模块代码，例如.json：`import("./data.json", { with: { type: "json" } });`
            - eg
            ```tsx
                // lazy在外面以避免被重新加载
                const Component = lazy(()=>import("./Component.tsx"));
                function bruh() {
                    return (
                        <Suspense fallback={<div>Loading...<div/>}>
                            <Component />
                        <Suspense />
                    )
                }
            ```
        - Suspense
            - 通过捕获children抛出的Promsie对象来判断要不要用fallback
            - thrown一个Promise并不会导致报错，只是简单地运行这个Promise并让Suspense捕获而已
            - 复习下scrollTop
                - 子元素的offsetTop和非static position的父容器的scrollTop对比下就能实现懒加载
                - offsetWidth包含padding不包含滚动条。scroll也只到padding不需要考虑滚动条
    - web应用的基础知识
        - Promise的所有操作
        - ES6
            - Promise
    - react的面经
    - 基于 SSE 的实时聊天交互、机器人回复的流式显示
        - 长连接，缓存块，pesudoMessage
    - 基于 JWT 和 React Router 实现了智能路由认证，支持动态路由渲染和基于角色的 UI 展示。
        - decorator
    - 自定义Hooks来抽象数据获取和表单处理逻辑，提升了代码的可读性和可维护性。
        - 为什么要自定义hook？
            - 复用、封装逻辑
            - 分离逻辑：把和UI没有直接关系的运算、数据获取逻辑全部封装成钩子，让组件只关心怎么用数据渲染UI，而不用理会数据的预处理
    - 给上面的各种知识点找例子

    - 工程化
    - webpack、ajax
    - 怎么测试的（研究点测试的术语）

CSS：
- css实现水平居中的方式，多说几种
    - margin: 0 auto;
    - jusitify-content: center;
    - trans
- 如何清除浮动
    - 设置块状clear: both的空兄弟元素
    - 父级变成BFC
- 文字超出盒子的宽高，对其隐藏设置什么属性
    - white-space: nowrap; /* 禁止换行 */
    - overflow: hidden; /* 超出部分隐藏 */
    - text-overflow: ellipsis; /* 显示省略号 */
- 如何解决塌陷问题：例如 父元素里有子元素，给子元素设置margin-top:50;父盒子和子盒子一块塌陷 
    - 隔离父盒子和子盒子
    - 父级变成BFC
- ES6新特性有哪些
- promise的状态
    - pending，fulfilled，rejected
- resolve是什么状态
    - resolve之后就是fulfilled状态
- promise的出现是为了解决什么问题
    - 回调地狱
- 闭包是什么
    - 闭包允许函数访问其***定义时的作用域***，即使函数在其定义的作用域之外执行。
    - 所以约等于箭头函数？
- 说下原型链
- 普通函数和箭头函数有什么区别
- 修改this的几种方式
    - 因为this的使用永远和函数或者方法有关，所以只考虑call apply bind就行
    - call：传入上下文和逐一传入参数并立刻运行
    - apply：传入上下文和参数数组并立刻运行
    - bind：绑定上下文和一部分参数并返回一个新函数。这个新函数的参数会优先接收绑定的参数再顺序接收调用传入的参数
- sessionStorage和localStorage的区别
    - sessionStorage：
        - 生命周期：页面会话期间有效，关闭页面后数据被清除。
        - 作用域：仅在当前标签页有效。
    - localStorage：
        - 生命周期：永久存储，除非手动清除。
        - 作用域：跨标签页共享。
- ts中type 和interface的相同点
    - 定义类型：都可以用来定义对象、函数、类等的类型。
    - 扩展：都可以通过 extends 或 & 进行扩展。
    - 实现：都可以被类实现（implements）。
- General(todo)
    - 计算机基础
        - os
            - 内存模型
            - 进程线程
            - 内核
        - network
            - 分层模型
            - HTTP/HTTPS
            - TCP，RPC
            - 
    - 个人介绍
        - 大三学生
        - 有过多段实习
        - 有过完整的software开发经验
    - 项目介绍
        - Corpus
        - 实习


说一下项目中的难点、亮点
- CorpusChat：
    - 亮点：
        - 1. 真实项目，需要与客户沟通、设计整套软件流程。还涉及了一部分的UI设计
        - 2. 实现了一个很热门的概念：RAG，因此比较了解AI服务的一些前端要点
        - 3. 全栈
        - 3. Redux框架的使用：解耦数据的跨组件传递，让代码更清晰可维护
            - Context缺点
                - 大量switch来判断fetch操作
                - 性能问题：当 Context 的值发生变化时，所有消费该 Context 的组件都会重新渲染，即使它们只依赖 Context 的一部分数据。需要通过 useMemo 或 useCallback 优化性能。
                - 不适合复杂状态管理：缺乏 Redux 中的中间件、时间旅行调试等功能。且状态更新逻辑分散在各个组件中，难以集中管理。
                - 调试困难：没有 Redux DevTools 这样的强大调试工具。
            - Redux优点
                - 集中式状态管理：所有状态存储在单一的 Store 中，状态更新逻辑集中在 Reducer 中，加上状态分片，易于管理、追踪和测试。
                - 强大的中间件支持：支持中间件（如 redux-thunk、redux-saga），可以处理异步操作、日志记录等。
                - 时间旅行调试：通过 Redux DevTools，可以回溯和重放状态变化，方便调试。
                - 性能优化：通过 useSelector 选择性订阅状态，浅对比返回值，避免不必要的重新渲染。
        - 4. 云服务
    - 难点：
        - 使用了Azure的beta功能：AI 助理。实际开发中有很多不可控的因素，例如
            - 需要配合Azure云服务的数据结构，自己封装AI的输入与输出并与前端交互
                - 比如AI输出的内容是纯文字，我需要将其渲染为可读性更强的
            - beta功能有不完善的地方，源码有时会出现问题，需要在保证响应速度的同时妥善处理可能的错误信息
                - 比如AI assistant有时会输出到一半卡死报错，必须设置妥善前端逻辑来在流式输出时删除信息
            - 文档不清晰的地方常常需要阅读一部分源码
                - 比如后端需要
            - 客户要求有时候难以靠现有功能完成，只能自己解决
                - 这个比较后端，看看面试官想不想知道吧
        - redux学习路线比较陡峭

你要知道你为什么用这个库，库的大致设计理念
库的简易版
- Redux设计理念：
    - 统一状态管理
    - 把复杂的状态管理逻辑组合封装为一个个行为，提高可读性（也就是用文字的action来封装复杂的setState）
- redux手动实现
    - store：包含了state、reducer、listener的对应关系
    - getState函数：获得state
    - listener队列：包含着所有订阅者的通知用回调函数（也就是selector）
    - subcribe函数：把订阅者的通知用回调函数传入listener队列。这个回调函数需要与组件声明周期挂钩，如useState的setter，useEffect的依赖数组值改变等等
    - reducer函数：传入action和state，并对action做出对应修改
    - dispatch函数：更改state，通知listener队列里对应的selector
    - useSelector钩子：封装subscribe和getState的钩子
        - 嵌套钩子原来也会重新渲染组件
    - 通过action的type和订阅时的type分片，只让指定的
- 懒加载
    - 进阶一点就是懒加载用纯JS怎么实现
        - Intersection Observer API
            - eg
                ```ts
                const observer = new IntersectionObserver(entries => {
                    for (const i of entries) {
                        if (i.isIntersecting) { // 当目标元素出现在视图内
                            const img = i.target;
                            const trueSrc = img.getAttribute("data-src");
                            setTimeout(() => {
                                img.setAttribute("src", trueSrc); // 方便展示懒加载效果
                            }, 1000);
                            observer.unobserve(img); // 停止监听此元素
                        }
                    }
                });
                ```
        - 子元素offsetTop < 父元素clientHeight + 父元素scrollTop
        - window.pageYOffset ? window.pageYOffset : window.document.documentElement.scrollTop
- 路由
    - 那你就要知道路由用纯JS怎么实现，监听hashChange和History API两种方式的话，又怎么写代码呢？
    - History API
        - `history.pushState({}, '', path);`：更改路径并跳转
            - history.pushState 接收三个参数：
            - state：一个状态对象，与新的 URL 关联。可以是任意可序列化的数据。
            - title：新页面的标题。目前大多数浏览器忽略此参数。
            - url：新的 URL。
        - `popstate`：监听 popstate 事件（浏览器前进/后退时触发）。
    - hashChange
        - window.location.hash
    - 解析路径与捕获参数：react的路径定义方法有些语法糖，比如`:id`要变成`"id": <value>`。需要分析哪一段是把接收的path的id捕获出来放进
    - 保存路径与对应组件的关系：obj就行
    - navigate函数：`history.pushState({}, '', path);`后，render保存的对应组件
    - render函数：清除现有DOM，挂载新DOM
    - 首屏加载：监听`DOMContentLoaded`
    - handleRouteChange
        - window.location.pathname;
        - eg
        ```ts
        // 路由配置
        const routes = [
            { path: '/', component: Home },
            { path: '/about', component: About },
            { path: '/user/:id', component: User },
            { path: '*', component: NotFound } // 404 页面
        ];
        
        // 路径转正则表达式（简化版）
        function pathToRegexp(path, keys) {
            const pattern = path.replace(/:(\w+)/g, (_, key) => {
                keys.push({ name: key });
                return '([^\/]+)';
            });
            return new RegExp(`^${pattern}$`);
        }

        // 路由匹配
        function matchRoute(path, routes) {
            for (const route of routes) {
                const keys = [];
                const regex = pathToRegexp(route.path, keys);
                const match = regex.exec(path);

                if (match) {
                    const params = keys.reduce((acc, key, index) => {
                        acc[key.name] = match[index + 1];
                        return acc;
                    }, {});
                    return { ...route, params };
                }
            }
            return null;
        }

        // 动态组件渲染
        function render(component, params) {
            const app = document.getElementById('app');
            app.innerHTML = '';
            const element = document.createElement('div');
            element.innerHTML = component(params);
            app.appendChild(element);
        }

        // 导航
        function navigate(path) {
            history.pushState({}, '', path);
            handleRouteChange();
        }

        // 处理路由变化
        function handleRouteChange() {
            const path = window.location.pathname;
            const matchedRoute = matchRoute(path, routes);

            if (matchedRoute) {
                render(matchedRoute.component, matchedRoute.params);
            } else {
                render(NotFound);
            }
        }

        // 初始化
        window.addEventListener('popstate', handleRouteChange);
        document.addEventListener('DOMContentLoaded', handleRouteChange);

        // 组件定义
        function Home() {
            return '<h1>Home</h1>';
        }

        function About() {
            return '<h1>About</h1>';
        }

        function User(params) {
            return `<h1>User: ${params.id}</h1>`;
        }

        function NotFound() {
            return '<h1>404 Not Found</h1>';
        }


        // 初始化渲染
        handleRouteChange();
        
        ```

- 说几条性能优化的方案
- 防抖与节流
    - 防抖：短时间内多次，只算最后一次
    - 节流：短时间内多次，每一稳定时间区间只算一次
- 输入url发生什么
    - URL 解析：解析 URL，提取协议、域名、路径等信息。
    - DNS 解析：将域名解析为 IP 地址。
    - 建立 TCP 连接：通过三次握手建立连接，如果是 HTTPS 则进行 TLS/SSL 握手。
    - 发送 HTTP 请求：构造并发送 HTTP 请求。
    - 服务器处理请求：服务器处理请求并生成 HTTP 响应。
    - 接收 HTTP 响应：浏览器接收并解析 HTTP 响应。
    - 渲染网页：解析 HTML、CSS，构建 DOM 树和 CSSOM 树，生成渲染树，布局和绘制。
        - 解析 HTML：浏览器解析 HTML 文件，构建 DOM 树（Document Object Model）。
        - 加载外部资源：浏览器根据 HTML 中的标签（如 <link>、<script>、<img>），加载 CSS、JavaScript、图片等外部资源。
        - 解析 CSS：浏览器解析 CSS 文件，构建 CSSOM 树（CSS Object Model）。
        - 构建渲染树：浏览器将 DOM 树和 CSSOM 树合并，生成渲染树（Render Tree）。
        - 布局（Layout）：浏览器计算渲染树中每个节点的位置和大小（Layout 或 Reflow）。
        - 绘制（Paint）：浏览器将渲染树绘制到屏幕上（Paint）。
        - 执行 JavaScript：浏览器执行 JavaScript 代码，可能会修改 DOM 或 CSSOM，触发重新布局和绘制。
            - 网页交互：处理用户交互事件，动态更新页面。
            - 关闭连接：通过四次挥手关闭 TCP 连接。
            - 缓存：缓存静态资源，加速下次访问。

- 闭包原理、作用、应用场景
    - 保存状态：闭包可以保存函数执行时的状态，即使函数已经执行完毕。
    - 实现私有变量：通过闭包，可以模拟私有变量，避免外部直接访问和修改。
    - 延迟执行：闭包可以用于实现延迟执行（如回调函数、定时器）。
    - 模块化：闭包可以用于创建模块，封装私有方法和变量。
- 为什么想申请这个岗位
    1. 个人发展
        - 前端的开发
        - 转正机会、前沿的商业化工业化的技术
    2. 字节跳动
        - 始终创业 Always Day 1：展示了谦逊、上进心和初心

xss

http和https在header上有区别吗

自我介紹
- 香港大学
- 全栈偏前端
    - 技术栈：js/ts react
- 实习/工作经历比较丰富
    - 工作经历：Corpus兼职工作、RAG概念
    - 实习：大公司、小公司

前端加密与http加密？？



问webpack中loader和Plugin的区别

# temp
	hyperlink
	collocate
	前端优化（control enter）
	multi corpus
	new corpus


（Software版本
Corpus（以下内容是机翻的）: 
- 参与在 Azure 上开发学术用网络应用程序，涵盖从需求分析到测试和启动的整个过程，从前端到后端。利用自定义知识库实施人工智能助手，为学生提供特定领域的指导。
- 设计高质量代码。例如，采用阿里巴巴的 MVC 架构，在网关级实现全局异常处理，解耦聊天机器人事件循环处理器等，以提高可维护性和性能。
- 通过实施轻量级延迟消息队列来节省流量峰值，并在本地缓存常用和计算密集型数据，从而减轻服务器压力。
- 扩展核心功能，包括用户身份验证、基于角色的访问控制、人工智能语料分析模块等。
- 独立解决了 5 项需求，推出了 10 多个应用程序接口，确保了项目部署的及时性和稳定性。
- 成功向公众发布了 3 个 1.1.0 版本。


（Frontend 版本
润色后的中文版本
- 实现AI聊天平台核心功能，包括基于SSE的实时聊天交互、机器人响应流式传输显示及聊天记录下载等功能。
- 将状态管理从React Context迁移至Redux，利用Redux Thunk封装异步请求，提升状态管理可维护性。
- 基于JWT和React Router实现智能路由鉴权，支持动态路由渲染，根据不同用户角色展示不同界面。
- 创建自定义Hooks（如useFetch、useForm），抽象数据获取和表单处理逻辑，提升代码复用性和可维护性。
- 通过useMemo、useCallback优化渲染性能，结合React.lazy和Suspense实现动态路由加载，减少首屏加载时间，提升用户体验。

英文翻译版本
- Implemented core features of the AI chat platform, including real-time chat interaction based on SSE, streaming display of bot responses, chat history download functionality, etc.
- Migrated state management from React Context to Redux, utilizing Redux Thunk to encapsulate asynchronous requests and improve state maintainability.
- Implemented intelligent route authentication based on JWT and React Router, enabling dynamic route rendering and role-based UI display.
- Created custom Hooks to abstract data fetching and form handling logic, enhancing code readibility and maintainability.
- Optimized rendering performance with useMemo and useCallback, and implemented dynamic route loading using React.lazy and Suspense to reduce initial load time and improve user experience.


